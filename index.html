<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickChart</title>

  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
</head>

<body>
  <span id="width-measurer"></span>

  <div class="container">
    <div class="d-flex align-items-center justify-content-between mb-4 header-bar">
      <h1 class="m-0">
        <img src="QuickChartLogoWide.svg" alt="QuickChart" class="img-fluid"
          style="max-width: 200px; height: auto; vertical-align: middle; margin-right: 0.5em;"
          onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';" />
        <span style="display:none;">QuickChart</h1>
      <div class="d-flex align-items-center">
        <button id="bugReportBtn" class="btn btn-outline-primary me-3" title="Report an issue">
          <i class="bi bi-bug-fill"></i>
        </button>
        <h3 class="m-0 fst-italic fw-bold text-danger">Beta Version</h3>
        <button id="darkModeToggle" class="btn btn-outline-secondary ms-3" title="Toggle dark/light mode">
          <i class="bi bi-moon-fill"></i>
        </button>
      </div>
      <div class="header-right">
        <div class="input-group" id="jsonFileInputGroup" style="max-width: 400px;">
          <input type="text" id="jsonFileInput" class="form-control form-control-sm"
            placeholder="Config Name (e.g., default)" value="default"
            title="Enter configuration name (e.g., default, trauma) and click Load">
          <button id="loadJsonBtn" class="btn btn-primary btn-sm">Load</button>
        </div>
        <div class="toggle-newrun-row">
          <div class="form-check form-switch" title="Toggle inclusion of section titles in the final narrative">
            <input class="form-check-input" type="checkbox" id="toggleSectionTitles" checked>
            <label class="form-check-label" for="toggleSectionTitles">
              Output Section Titles
            </label>
          </div>
          <button id="newRunBtn" class="btn btn-warning btn-sm"
            title="Clear the current narrative and start over with the loaded configuration's defaults">New Run</button>
        </div>
      </div>
    </div>

    <div id="sectionContainer">
    </div>

    <button id="generateBtn" class="btn btn-primary mb-3" title="Generate the final narrative text below">Generate Final
      Text</button>
    <button id="validateBtn" class="btn btn-warning mb-3 ms-2" title="Check for empty fields without generating text">Validate</button>

    <div class="mb-3">
      <label for="finalText" class="form-label fw-bold">Final Narrative</label>
      <textarea class="form-control" id="finalText" rows="6"
        placeholder="Generated narrative will appear here..."></textarea>
    </div>

    <button id="copyBtn" class="btn btn-success mb-5" title="Copy the generated narrative to the clipboard">Copy to
      Clipboard</button>

    <div id="disclaimer" class="alert alert-secondary py-1 text-center small" role="alert">
      <strong>Disclaimer:</strong> Data is stored in your browser's local storage. Clearing browser data will remove
      saved narrative. No PHI is sent to a server.
    </div>
    <div id="license" class="alert alert-light py-1 text-center small" role="alert"
      xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
      <a property="dct:title" rel="cc:attributionURL" href="https://xzero121.github.io/QuickChart/">QuickChart</a> by
      <span property="cc:attributionName">B. Brown, EMT-B</span> is licensed under
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/?ref=chooser-v1" target="_blank"
        rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-ND 4.0
        <img class="cc-icon" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"
          alt="CC icon"><img class="cc-icon"
          src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt="BY icon"><img
          class="cc-icon" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"
          alt="NC icon"><img class="cc-icon"
          src="https://mirrors.creativecommons.org/presskit/icons/nd.svg?ref=chooser-v1" alt="ND icon">
      </a>
    </div>
  </div>
  <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="confirmationModalLabel">Confirmation</h5>
          <div class="d-flex align-items-center">
            <button type="button" class="btn btn-sm btn-outline-secondary me-2" id="confirmationLockToggle" 
                    title="Toggle: Reset locked sentences" style="display: none;">
              <i class="bi bi-lock-fill"></i>
            </button>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
        </div>
        <div class="modal-body" id="confirmationModalBody">
        </div>
        <div class="modal-footer d-flex align-items-center justify-content-between">
          <div id="confirmationDisclaimer" class="text-muted small">
          </div>
          <div>
            <button type="button" class="btn btn-primary" id="confirmYesBtn">Yes</button>
            <button type="button" class="btn btn-secondary" id="confirmNoBtn" data-bs-dismiss="modal">No</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="bugReportModal" tabindex="-1" aria-labelledby="bugReportModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="bugReportModalLabel">Report an Issue</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <textarea id="bugDescription" class="form-control" rows="4" placeholder="Describe the issue..."></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="submitBug">Submit</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // --- Constants ---
    const DEBUG = false; // Set to true to enable console logging
    const placeholderRegex = /\[(text|number|dropdown|customDropdown):([^:\]]+)(?::([^:\]]+))?\]/g;
    const incrementalRegex = /\[\+([^\[\]]*(?:\[[^\]]*\][^\[\]]*)*)\]/g; // Updated regex for incremental content with nested brackets
    const LOCAL_STORAGE_KEY = 'QuickChart-Beta';
    const MIN_INLINE_WIDTH = 50; // Min width for inline fields (px)
    const MAX_INLINE_WIDTH_PERCENT = 80; // Max width relative to parent (%)
    const DEFAULT_CONFIG_NAME = 'default'; // Default config file name
    const HIDDEN_ITEM_MARKER = '*'; // Prefix for dropdown options hidden by default

    // --- Global State ---
    let rawCommonSentences = [];
    let commonSentences = [];
    let globalDropdownOptions = {};
    let defaultNarrativeSections = []; // Holds the *defaults* from the loaded JSON
    let narrativeSections = []; // Holds the *current working state* (potentially modified by user)
    let fuse;
    let sentenceIdCounter = 1;
    let widthMeasurerSpan; // Ref to hidden span for width calc
    let currentConfigName = DEFAULT_CONFIG_NAME; // Track currently loaded config
    let activeDropdowns = []; // Track visible dropdown suggestion boxes

    // --- Fuse.js Options ---
    const fuseOptions = {
      keys: ["display", "searchable"],
      includeMatches: true,
      threshold: 0.1,
      minMatchCharLength: 2,
      ignoreLocation: true
    };

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function () {
      initializeApp();
    });

    function initializeTooltips() {
      const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
      tooltipTriggerList.map(function (tooltipTriggerEl) {
        if (!bootstrap.Tooltip.getInstance(tooltipTriggerEl)) {
          return new bootstrap.Tooltip(tooltipTriggerEl);
        }
        return null;
      });
      if (DEBUG) console.log("Tooltips initialized.");
    }

    async function initializeApp() {
      if (DEBUG) console.log("Initializing QuickChart...");
      widthMeasurerSpan = document.getElementById('width-measurer');
      if (!widthMeasurerSpan) console.error("Width measurer span not found!");

      attachHeaderListeners();
      initializeDarkMode(); // Add dark mode initialization
      initializeBugReport(); // Initialize bug report functionality

      try {
        const savedConfigName = localStorage.getItem("QuickChart-Beta-Config");
        if (!savedConfigName) {
          if (DEBUG) console.warn("No saved configuration name found. Using default.");
          await loadConfiguration(DEFAULT_CONFIG_NAME, true);
        } else {
          if (DEBUG) console.log(`Loaded saved configuration name: ${savedConfigName}`);
          await loadConfiguration(savedConfigName, true);
        }
        loadState();
        buildSectionsUI();
        initializeTooltips();
        attachAllEventListeners(); // Consolidated event listener attachment
        adjustAllInitialSizes();

        // Remove initial placeholder check - only check when generating text
        if (DEBUG) console.log("QuickChart Initialized Successfully.");
      } catch (err) {
        console.error("Failed to initialize QuickChart:", err);
        showConfirmationModal("Initialization Error", `Could not load initial configuration. Please check console or refresh. Error: ${err.message}`, "", () => { }, () => { }, true);
        document.getElementById('sectionContainer').innerHTML = '<p class="text-danger">Error loading configuration.</p>';
      }
    }

    function attachAllEventListeners() {
      attachInputSizingListeners();
      attachBlurListeners();
      attachDropdownLogic();
    }

    function attachAllEventListenersForElement(element) {
      attachInputSizingListenersForElement(element);
      attachBlurListenersForElement(element);
      attachDropdownLogicForElement(element);
    }


    /** Attaches event listeners to header elements */
    function attachHeaderListeners() {
      const loadBtn = document.getElementById('loadJsonBtn');
      const fileInput = document.getElementById('jsonFileInput');
      const newRunBtn = document.getElementById('newRunBtn');

      // Attach event listeners to the load button and file input
      if (loadBtn && fileInput) {
        loadBtn.addEventListener('click', () => {
          const configName = fileInput.value.trim() || DEFAULT_CONFIG_NAME;
          showConfirmationModal(
            `Load Configuration: ${configName}?`,
            `Loading '${configName}' will discard your current narrative and replace it with the defaults from that configuration. Continue?`,
            "Your work will not be saved.",
            () => {
              const modalEl = document.getElementById("confirmationModal");
              // Use a one-time event listener for when the modal is hidden
              modalEl.addEventListener('hidden.bs.modal', async function handler() {
                modalEl.removeEventListener('hidden.bs.modal', handler); // Clean up
                await loadConfiguration(configName);
                resetToCurrentConfigDefaults(); // This will rebuild UI and reattach listeners
              }, { once: true });
            },
            () => { } // User cancelled
          );
        });
        fileInput.addEventListener("keypress", (e) => {
          if (e.key === 'Enter') { e.preventDefault(); loadBtn.click(); }
        });
      } else { console.error("Load button or file input not found."); }

      // Attach event listener to the new run button
      if (newRunBtn) {
        newRunBtn.addEventListener('click', () => {
          showConfirmationModal(
            "Start New Run",
            `This will discard changes and reset to the defaults for the '${currentConfigName}' configuration. Continue?`,
            "",
            () => resetToCurrentConfigDefaults(), // This will rebuild UI and reattach listeners
            () => { }, // User cancelled
            false, // Not single button
            true // Show lock toggle
          );
        });
      } else { console.error("New Run button not found."); }
    }

    async function loadConfiguration(configName, isInitialLoad = false) {
      const filename = `${configName.toLowerCase()}.json`;

      if (DEBUG) console.log(`Attempting to load configuration: ${filename}`);
      try {
        // First, load the global configuration
        let globalData = { commonSentences: [], globalDropdownOptions: {} };
        try {
          const globalResponse = await fetch('global.json');
          if (globalResponse.ok) {
            globalData = await globalResponse.json();
            if (DEBUG) console.log("Global configuration loaded.");
          } else {
            console.warn("Global configuration not found, using empty defaults.");
          }
        } catch (globalError) {
          console.warn("Failed to load global configuration:", globalError);
        }

        // Then load the template-specific configuration
        const response = await fetch(filename);
        if (!response.ok) {
          throw new Error(`Configuration file '${filename}' not found or could not be loaded (Status: ${response.status})`);
        }
        const data = await response.json();

        // Save the loaded config name to localStorage
        if (!isInitialLoad) {
          try {
            localStorage.setItem("QuickChart-Beta-Config", configName);
          } catch (e) {
            console.error("Failed to save config name.", e);
          }
        }

        // Merge global and local configurations
        // Global commonSentences come first, then local ones are added
        const globalSentences = globalData.commonSentences || [];
        const localSentences = data.commonSentences || [];
        rawCommonSentences = [...globalSentences, ...localSentences];

        // Merge dropdown options: local options override global options for the same key
        const globalOptions = globalData.globalDropdownOptions || {};
        const localOptions = data.localDropdownOptions || data.globalDropdownOptions || {};
        globalDropdownOptions = { ...globalOptions, ...localOptions };

        defaultNarrativeSections = data.narrativeSections || [];

        // Assign stable IDs on defaultNarrativeSections so locks persist across resets
        assignInitialIDs(defaultNarrativeSections);

        // Handle both old format (string) and new format (object with name/text or tabs)
        // Support both regular sentences and tabbed sentences
        commonSentences = rawCommonSentences
          .filter((s) => {
            // Keep strings, objects with text property, and objects with tabs array
            return typeof s === 'string' || (s && (s.text || (s.tabs && Array.isArray(s.tabs))));
          })
          .map((s) => {
            if (typeof s === 'string') {
              return {
                original: s,
                display: shortPlaceholderString(s),
                searchable: expandedPlaceholderString(s),
                name: null
              };
            }
            
            // Handle tabbed sentences
            if (s.tabs && Array.isArray(s.tabs)) {
              // For tabbed sentences, use the first tab's text for display/search
              const firstTabText = s.tabs[0]?.text || '';
              return {
                originalObject: s, // Store the full object including tabs
                original: firstTabText,
                display: s.name || shortPlaceholderString(firstTabText),
                searchable: expandedPlaceholderString(firstTabText),
                name: s.name,
                hasTabs: true
              };
            }
            
            // Handle regular sentences with text
            return {
              original: s.text,
              display: shortPlaceholderString(s.text),
              searchable: expandedPlaceholderString(s.text),
              name: s.name
            };
          });
        fuse = new Fuse(commonSentences, fuseOptions);

        currentConfigName = configName;
        document.getElementById('jsonFileInput').value = configName;

        if (!isInitialLoad) {
          showConfirmationModal("Load Successful", `Configuration '${configName}' loaded successfully.`, "", () => { }, () => { }, true);
        }
        if (DEBUG) console.log(`Configuration '${configName}' loaded.`);
      } catch (error) {
        console.error(`Failed to load or parse configuration '${filename}':`, error);
        showConfirmationModal("Load Error", `Could not load configuration '${configName}'. Please check the name and ensure the file exists. <br><small>(${error.message})</small>`, "", () => { }, () => { }, true);
        document.getElementById('jsonFileInput').value = currentConfigName;
        throw error;
      }
    }

    // --- State Management ---
    function loadState() {
      const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (savedState) {
        try {
          let loadedState = JSON.parse(savedState);

          // If there was previously saved state, merge locked sentences with defaults
          // to ensure locked status persists through refresh
          const lockedSentenceMap = new Map();

          // First, identify all locked sentences from the loaded state
          loadedState.forEach(section => {
            if (!section.sentences) return;
            section.sentences.forEach(s => {
              if (s.locked && s.id) {
                lockedSentenceMap.set(s.id, {
                  text: s.text,
                  values: s.values ? { ...s.values } : {},
                  tabValues: s.tabValues ? JSON.parse(JSON.stringify(s.tabValues)) : [],
                  activeTabIndex: s.activeTabIndex,
                  locked: true
                });
              }
            });
          });

          // Set narrative sections to loaded state
          narrativeSections = loadedState;

          // Ensure locked state is preserved even if IDs get reassigned
          if (lockedSentenceMap.size > 0) {
            assignInitialIDs(narrativeSections);

            // Re-apply locked status and content to matching sentences
            narrativeSections.forEach(section => {
              if (!section.sentences) return;
              section.sentences.forEach(s => {
                if (lockedSentenceMap.has(s.id)) {
                  const lockedData = lockedSentenceMap.get(s.id);
                  s.locked = true;
                  s.text = lockedData.text; // Preserve edited text
                  s.values = lockedData.values;
                  if (s.tabs && lockedData.tabValues) {
                    s.tabValues = lockedData.tabValues;
                    if (typeof lockedData.activeTabIndex === 'number') {
                      s.activeTabIndex = lockedData.activeTabIndex;
                    }
                  }
                }
              });
            });
          }

          if (DEBUG) console.log("Working state loaded from localStorage with locked sentences preserved.");
        } catch (e) {
          console.error("Failed to parse saved state, using defaults from loaded config.", e);
          localStorage.removeItem(LOCAL_STORAGE_KEY);
          resetToCurrentConfigDefaults(false); // Don't rebuild UI yet
        }
      } else {
        if (DEBUG) console.log("No saved working state found, using defaults from loaded config.");
        resetToCurrentConfigDefaults(false); // Don't rebuild UI yet
      }
      sentenceIdCounter = findHighestSentenceId(narrativeSections) + 1;
    }

    function saveState() {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(narrativeSections));
      } catch (e) {
        console.error("Failed to save state.", e);
        showConfirmationModal("Save Error", "Could not save changes to browser storage. Storage might be full.", "", () => { }, () => { }, true);
      }
    }

    // --- resetToCurrentConfigDefaults remains the same but will now re-apply locks correctly ---
    function resetToCurrentConfigDefaults(rebuildUI = true) {
      // Store locked sentences with their values before reset
      const lockedSentenceData = new Map();
      narrativeSections.forEach(sec =>
        sec.sentences?.forEach(s => {
          if (s.locked) {
            // Store complete sentence data including text and all values
            lockedSentenceData.set(s.id, {
              text: s.text, // Store the text content specifically
              values: s.values ? { ...s.values } : {}, // Copy values
              tabValues: s.tabValues ? JSON.parse(JSON.stringify(s.tabValues)) : [], // Deep copy tab values if present
              activeTabIndex: s.activeTabIndex // Remember active tab
            });
          }
        })
      );

      if (DEBUG) console.log(`Resetting to defaults for config: ${currentConfigName}`);
      narrativeSections = JSON.parse(JSON.stringify(defaultNarrativeSections));
      assignInitialIDs(narrativeSections); // IDs preserved from defaultNarrativeSections, so lockedIDs now match

      // Re-apply locks and restore their values
      narrativeSections.forEach(sec =>
        sec.sentences?.forEach(s => {
          if (lockedSentenceData.has(s.id)) {
            const savedData = lockedSentenceData.get(s.id);
            s.locked = true;

            // Restore text and values
            if (savedData.text) {
              s.text = savedData.text;
            }

            // For non-tabbed sentences
            if (savedData.values && Object.keys(savedData.values).length > 0) {
              s.values = savedData.values;
            }

            // For tabbed sentences
            if (s.tabs && savedData.tabValues && savedData.tabValues.length > 0) {
              s.tabValues = savedData.tabValues;
              // Only restore activeTabIndex if it's valid for this sentence
              if (typeof savedData.activeTabIndex === 'number' &&
                savedData.activeTabIndex >= 0 &&
                savedData.activeTabIndex < s.tabs.length) {
                s.activeTabIndex = savedData.activeTabIndex;
              }
            }
          }
        })
      );

      saveState(); // Save this state so it persists across refreshes

      if (rebuildUI) {
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }

      // Clear the final text area and warnings
      document.getElementById("finalText").value = "";

      // Clear the placeholder warning without checking
      showPlaceholderWarning(false);

      // Clear the unadded sentence warning
      showUnaddedSentenceWarning(false);

      // Clear the locked sentences info
      const copyLockedInfoEl = document.getElementById('copyLockedInfo');
      if (copyLockedInfoEl) {
        copyLockedInfoEl.style.display = 'none';
      }
    }

    // --- ID and Value Initialization ---
    function assignInitialIDs(sections) {
      let maxId = 0;
      sections.forEach(section => {
        if (!section.sentences) section.sentences = [];
        section.sentences.forEach(sentenceObj => {
          if (!sentenceObj.id || !sentenceObj.id.startsWith('sentence-')) {
            sentenceObj.id = "sentence-" + sentenceIdCounter++;
          } else {
            const idNum = parseInt(sentenceObj.id.split('-')[1]);
            if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
          }
          initializeSentenceValues(sentenceObj); // Ensure values/tabs are initialized
        });
      });
      sentenceIdCounter = Math.max(sentenceIdCounter, maxId + 1);
    }

    // Add dark mode initialization function
    function initializeDarkMode() {
      if (DEBUG) console.log("Initializing dark mode...");
      const darkModeToggle = document.getElementById('darkModeToggle');

      if (!darkModeToggle) {
        console.error("Dark mode toggle button not found!");
        return;
      }

      // Check localStorage for user preference
      const isDarkMode = localStorage.getItem('darkMode') === 'true';

      // Apply initial theme based on user preference
      if (isDarkMode) {
        document.documentElement.setAttribute('data-bs-theme', 'dark');
        darkModeToggle.innerHTML = '<i class="bi bi-sun-fill"></i>';
      } else {
        document.documentElement.setAttribute('data-bs-theme', 'light');
        darkModeToggle.innerHTML = '<i class="bi bi-moon-fill"></i>';
      }

      // Add event listener for toggle button
      darkModeToggle.addEventListener('click', () => {
        const currentTheme = document.documentElement.getAttribute('data-bs-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

        // Update theme attribute
        document.documentElement.setAttribute('data-bs-theme', newTheme);

        // Update button icon
        darkModeToggle.innerHTML = newTheme === 'dark'
          ? '<i class="bi bi-sun-fill"></i>'
          : '<i class="bi bi-moon-fill"></i>';

        // Save preference to localStorage
        localStorage.setItem('darkMode', newTheme === 'dark');

        if (DEBUG) console.log(`Theme switched to: ${newTheme}`);
      });

      if (DEBUG) console.log("Dark mode initialization complete");
    }

    function findHighestSentenceId(sections) {
      let maxId = 0;
      sections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.id && sentenceObj.id.startsWith('sentence-')) {
            const idNum = parseInt(sentenceObj.id.split('-')[1]);
            if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
          }
        });
      });
      return maxId;
    }

    function initializeSentenceValues(sentenceObj) {
      // Initialize for tabbed sentences
      if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
        if (typeof sentenceObj.activeTabIndex === "undefined" || sentenceObj.activeTabIndex >= sentenceObj.tabs.length) {
          sentenceObj.activeTabIndex = 0;
        }
        if (!sentenceObj.tabValues || !Array.isArray(sentenceObj.tabValues) || sentenceObj.tabValues.length !== sentenceObj.tabs.length) {
          sentenceObj.tabValues = sentenceObj.tabs.map(() => ({}));
        } else {
          sentenceObj.tabValues = sentenceObj.tabValues.map(valStore =>
            (typeof valStore === 'object' && !Array.isArray(valStore) && valStore !== null) ? valStore : {}
          );
        }
      } else { // Initialize for non-tabbed sentences
        if (!sentenceObj.values || Array.isArray(sentenceObj.values)) {
          sentenceObj.values = {};
        }
        
        // For incremental sentences, initialize array-based values if needed
        if (sentenceObj.text && (sentenceObj.text.startsWith('+') || sentenceObj.text.startsWith('++'))) {
          if (!sentenceObj.incrementalValues) {
            sentenceObj.incrementalValues = {};
          }
        }
      }
      
      // Initialize incremental count for sentences that start with + or ++
      if (sentenceObj.text && (sentenceObj.text.startsWith('+') || sentenceObj.text.startsWith('++'))) {
        if (typeof sentenceObj.incrementCount === 'undefined') {
          sentenceObj.incrementCount = 1;
        }
      }
    }

    // --- String Manipulation Helpers ---
    function shortPlaceholderString(sentence) {
      // Handle undefined or null sentences
      if (!sentence) {
        return '';
      }
      // Remove leading + or ++ for display purposes
      let cleanSentence = sentence;
      if (sentence.startsWith('++')) {
        cleanSentence = sentence.substring(2);
      } else if (sentence.startsWith('+')) {
        cleanSentence = sentence.substring(1);
      }
      
      // Process incremental content for display (show just one instance)
      const processedSentence = cleanSentence.replace(incrementalRegex, '$1');
      // Convert \n to spaces for display in suggestions
      const displaySentence = processedSentence.replace(/\\n/g, ' ');
      return displaySentence.replace(placeholderRegex, (match, type, label) => `[${label}]`);
    }
    
    function expandedPlaceholderString(sentence) {
      // Handle undefined or null sentences
      if (!sentence) {
        return '';
      }
      // Remove leading + or ++ for search purposes
      let cleanSentence = sentence;
      if (sentence.startsWith('++')) {
        cleanSentence = sentence.substring(2);
      } else if (sentence.startsWith('+')) {
        cleanSentence = sentence.substring(1);
      }
      
      // Process incremental content for search (show just one instance)
      const processedSentence = cleanSentence.replace(incrementalRegex, '$1');
      // Convert \n to spaces for search
      const searchSentence = processedSentence.replace(/\\n/g, ' ');
      return searchSentence.replace(placeholderRegex, (match, theType, label, opts) => opts ? `[${label}(${opts})]` : `[${label}]`);
    }

    // --- UI Building ---
    function buildSectionsUI() {
      const container = document.getElementById("sectionContainer");
      if (!container) {
        console.error("Section container not found.");
        return;
      }
      container.innerHTML = ""; // Clear existing content
      narrativeSections.forEach(sec => {
        const sectionEl = createSectionElement(sec);
        container.appendChild(sectionEl);
      });
      makeSentencesDraggable(); // Make new sentences draggable
      initializeTooltips(); // Re-initialize tooltips for new elements
      // Event listeners (for inputs, dropdowns etc.) are attached via attachAllEventListeners() after full build
      // or attachAllEventListenersForElement() when adding single items.
    }

    function createQuickAddButtons(partLabel) {
      // Find the default section to get QuickSentence placeholders
      // (use defaultNarrativeSections, not the runtime narrativeSections)
      const defaultSection = defaultNarrativeSections.find(s => s.part === partLabel);
      if (!defaultSection || !defaultSection.sentences) {
        return null;
      }
      
      // Find all QuickSentence placeholders in this section's default sentences
      const quickSentenceNames = [];
      defaultSection.sentences.forEach((s, index) => {
        if (s.QuickSentence) {
          quickSentenceNames.push({ name: s.QuickSentence, index: index });
        }
      });
      
      if (quickSentenceNames.length === 0) {
        return null;
      }
      
      const container = document.createElement("div");
      container.classList.add("quick-add-container");
      
      quickSentenceNames.forEach(qs => {
        // Find the matching common sentence by name
        const sentence = commonSentences.find(s => s.name && s.name.toLowerCase() === qs.name.toLowerCase());
        if (!sentence) {
          console.warn(`QuickSentence "${qs.name}" not found in common sentences`);
          return;
        }
        
        const btn = document.createElement("button");
        btn.type = "button";
        btn.classList.add("btn", "btn-sm", "btn-outline-secondary", "quick-add-btn");
        btn.textContent = sentence.name || sentence.display.substring(0, 20) + "...";
        btn.title = sentence.display;
        btn.dataset.sentenceText = sentence.original;
        btn.dataset.section = partLabel;
        btn.dataset.quickSentenceName = qs.name;
        
        btn.addEventListener("click", () => {
          handleQuickAddSentence(partLabel, sentence, qs.name);
        });
        
        container.appendChild(btn);
      });
      
      return container;
    }

    function handleQuickAddSentence(partLabel, sentence, quickSentenceName) {
      // Create a sentence object from the sentence data
      let sentenceData;
      
      // Handle tabbed sentences
      if (sentence.hasTabs && sentence.originalObject) {
        // Clone the original object with tabs
        sentenceData = JSON.parse(JSON.stringify(sentence.originalObject));
      } else {
        // Regular sentence with text
        const sentenceText = typeof sentence === 'string' ? sentence : sentence.original;
        sentenceData = { text: sentenceText };
      }
      
      // Find the position of the QuickSentence placeholder in defaultNarrativeSections
      // (not narrativeSections, which may have been modified by user actions)
      const defaultSection = defaultNarrativeSections.find(s => s.part === partLabel);
      if (!defaultSection || !defaultSection.sentences) {
        addSentence(partLabel, sentenceData);
        return;
      }
      
      // Find the index of the QuickSentence placeholder in the defaults
      const placeholderIndex = defaultSection.sentences.findIndex(s => 
        s.QuickSentence && s.QuickSentence.toLowerCase() === quickSentenceName.toLowerCase()
      );
      
      if (placeholderIndex === -1) {
        // Placeholder not found in defaults, add to end
        addSentence(partLabel, sentenceData);
        return;
      }
      
      // Now find where to insert in the runtime narrativeSections
      // Count how many non-QuickSentence items come before this placeholder in defaults
      let targetPosition = 0;
      for (let i = 0; i < placeholderIndex; i++) {
        if (!defaultSection.sentences[i].QuickSentence) {
          targetPosition++;
        }
      }
      
      // Find the corresponding position in the runtime section
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section) {
        addSentence(partLabel, sentenceData);
        return;
      }
      
      if (!section.sentences) section.sentences = [];
      
      // Insert at the target position (or at end if position is beyond current length)
      const insertIndex = Math.min(targetPosition, section.sentences.length);
      addSentenceAtIndex(partLabel, sentenceData, insertIndex);
    }

    function createSectionElement(secObj) {
      const sectionDiv = document.createElement("div");
      sectionDiv.classList.add("narrative-section");
      sectionDiv.dataset.part = secObj.part;

      const header = document.createElement("div");
      header.classList.add("section-header");

      const titleWrapper = document.createElement("span");
      titleWrapper.classList.add("section-title-wrapper");

      const titleEl = document.createElement("h5");
      titleEl.classList.add("section-title", "m-0", "d-inline");

      const mainPartSpan = document.createElement("span");
      mainPartSpan.classList.add("section-title-main");
      mainPartSpan.innerText = secObj.part;
      titleEl.appendChild(mainPartSpan);

      if (secObj.subpart) {
        const subPartSpan = document.createElement("span");
        subPartSpan.classList.add("section-subpart");
        subPartSpan.innerText = secObj.subpart;
        titleEl.appendChild(subPartSpan); // This line was missing - append the subPartSpan to titleEl
      }
      titleWrapper.appendChild(titleEl);

      if (secObj.tooltip) {
        titleWrapper.setAttribute('data-bs-toggle', 'tooltip');
        titleWrapper.setAttribute('data-bs-placement', 'top');
        titleWrapper.setAttribute('title', secObj.tooltip);
      }
      header.appendChild(titleWrapper);

      // Create quick-add buttons for QuickSentence placeholders in this section (inline with header)
      const quickAddContainer = createQuickAddButtons(secObj.part);
      if (quickAddContainer) {
        header.appendChild(quickAddContainer);
      }

      sectionDiv.appendChild(header);

      const ul = document.createElement("ul");
      ul.classList.add("sentence-list");
      ul.dataset.part = secObj.part; // For SortableJS group identification
      if (secObj.sentences) {
        secObj.sentences.forEach(sentenceObj => {
          // Skip QuickSentence placeholders - they are just markers for button placement
          if (sentenceObj.QuickSentence) {
            return;
          }
          ul.appendChild(createSentenceElement(sentenceObj, secObj.part));
        });
      }
      sectionDiv.appendChild(ul);
      sectionDiv.appendChild(createAddSentenceForm(secObj)); // Add form for adding new sentences
      return sectionDiv;
    }

    function createSentenceElement(sentenceObj, partLabel) {
      initializeSentenceValues(sentenceObj); // Ensure values are ready
      const li = document.createElement("li");
      li.dataset.id = sentenceObj.id;
      li.dataset.part = partLabel; // Keep track of which part it belongs to

      // Check if this is an incremental sentence (either + or ++)
      const isIncremental = sentenceObj.text && (sentenceObj.text.startsWith('+') || sentenceObj.text.startsWith('++'));
      
      // Drag Handle
      const handle = document.createElement("span");
      handle.classList.add("drag-handle");
      handle.innerHTML = "&#9776;"; // Hamburger icon for dragging
      handle.title = "Drag to reorder or move to another section";
      li.appendChild(handle);

      // Content Area (for text and inline fields)
      const contentDiv = document.createElement('div');
      contentDiv.classList.add('sentence-content');

      if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
        li.classList.add("has-tabs");
        li.appendChild(createTabsContainer(sentenceObj)); // Tabs go above contentDiv
        sentenceObj.tabs.forEach((tab, i) => {
          contentDiv.appendChild(createTabPaneElement(sentenceObj, i));
        });
      } else {
        // For incremental sentences, process the text to expand [+content] based on incrementCount
        let textToProcess = isIncremental ? processIncrementalText(sentenceObj.text, sentenceObj.incrementCount) : sentenceObj.text;
        
        // Convert \n to <br> BEFORE calling buildInlineFields
        // Use \\n to match literal backslash-n characters from JSON
        if (textToProcess) {
          textToProcess = textToProcess.replace(/\\n/g, '<br>');
        }
        
        // For incremental sentences, pass the incrementalValues object to support multiple values per label
        contentDiv.innerHTML = buildInlineFields(textToProcess, sentenceObj.values, isIncremental ? sentenceObj.incrementalValues : undefined);
      }
      li.appendChild(contentDiv);

      // Top-right Controls (Edit, Lock, Remove buttons)
      const topControls = document.createElement('div');
      topControls.classList.add('sentence-controls');
      
      const topButtons = [
        createEditButton(sentenceObj, partLabel),
        createLockButton(sentenceObj, partLabel),
        createRemoveButton(sentenceObj.id, partLabel)
      ];
      
      topControls.append(...topButtons);
      li.appendChild(topControls);

      // Bottom-right Controls (Increment controls for incremental sentences)
      if (isIncremental) {
        li.style.setProperty('min-height', '4.5em'); // Ensure enough height for increment controls
        const bottomControls = document.createElement('div');
        bottomControls.classList.add('sentence-controls-bottom');
        bottomControls.appendChild(createIncrementControls(sentenceObj, partLabel));
        li.appendChild(bottomControls);
      }
      
      return li;
    }

    function createTabsContainer(sentenceObj) {
      const tabsContainer = document.createElement("div");
      tabsContainer.classList.add("tabs-container");
      sentenceObj.tabs.forEach((tab, i) => {
        const tabBtn = document.createElement("button");
        tabBtn.classList.add("tab-button");
        tabBtn.type = "button"; // Important for forms
        if (i === sentenceObj.activeTabIndex) tabBtn.classList.add("active");
        tabBtn.innerText = tab.title || `Tab ${i + 1}`;
        tabBtn.dataset.tabIndex = i;
        tabBtn.addEventListener("click", () => switchTab(sentenceObj.id, i));
        tabsContainer.appendChild(tabBtn);
      });
      return tabsContainer;
    }

    function createTabPaneElement(sentenceObj, tabIndex) {
      const tabPane = document.createElement("div");
      tabPane.classList.add("tab-pane");
      tabPane.dataset.tabIndex = tabIndex;
      if (tabIndex === sentenceObj.activeTabIndex) tabPane.classList.add("active");

      let tabContent = sentenceObj.tabs[tabIndex].text || "";
      
      // Convert \n to <br> BEFORE calling buildInlineFields
      // Use \\n to match literal backslash-n characters from JSON
      tabContent = tabContent.replace(/\\n/g, '<br>');
      
      const tabValues = sentenceObj.tabValues[tabIndex] || {}; // Ensure tabValues for this index exists
      tabPane.innerHTML = buildInlineFields(tabContent, tabValues);
      return tabPane;
    }

    function createRemoveButton(sentenceId, partLabel) {
      const removeBtn = document.createElement("button");
      removeBtn.classList.add("btn", "btn-sm", "remove-sentence-btn"); // Bootstrap and custom classes
      removeBtn.type = "button";
      removeBtn.innerHTML = "&times;"; // "X" symbol for remove
      removeBtn.title = "Remove Sentence";
      removeBtn.setAttribute('aria-label', 'Remove sentence');
      removeBtn.addEventListener("click", (e) => {
        e.stopPropagation(); // Prevent event bubbling
        showConfirmationModal("Remove Sentence", "Are you sure you want to remove this sentence?", "",
          () => removeSentence(partLabel, sentenceId),
          () => { } // No action on "No"
        );
      });
      return removeBtn;
    }

    function createEditButton(sentenceObj, partLabel) {
      const btn = document.createElement('button');
      btn.classList.add('btn', 'btn-sm', 'edit-sentence-btn');
      btn.title = 'Edit Sentence Text';
      btn.innerHTML = '<i class="bi bi-pencil-fill"></i>';
      btn.setAttribute('aria-label', 'Edit sentence text');
      btn.addEventListener('click', () => {
        // Get the content div that contains the sentence text
        const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
        const contentDiv = li.querySelector('.sentence-content');

        // Check if already in edit mode
        if (contentDiv.classList.contains('editing')) {
          if (DEBUG) console.log('Sentence is already in edit mode');
          return;
        }

        let currentText, activeTabIndex, isTabbed;

        // Determine if this is a tabbed sentence and get the appropriate text
        if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
          isTabbed = true;
          activeTabIndex = sentenceObj.activeTabIndex || 0;
          currentText = sentenceObj.tabs[activeTabIndex].text || "";
        } else {
          isTabbed = false;
          currentText = sentenceObj.text || "";
        }

        const originalHTML = contentDiv.innerHTML;

        // Mark as being edited
        contentDiv.classList.add('editing');

        // Disable increment controls if they exist
        const incrementControls = li.querySelectorAll('.increment-controls .increment-btn');
        incrementControls.forEach(btn => {
          btn.disabled = true;
          btn.classList.add('disabled');
        });

        // Create an editable textarea
        const textarea = document.createElement('textarea');
        textarea.classList.add('form-control', 'sentence-edit-textarea', 'auto-height-textarea');
        textarea.value = currentText;

        // Replace content with textarea
        contentDiv.innerHTML = '';
        contentDiv.appendChild(textarea);

        // Add save and cancel buttons
        const buttonsDiv = document.createElement('div');
        buttonsDiv.classList.add('edit-buttons', 'mt-2');

        const saveBtn = document.createElement('button');
        saveBtn.classList.add('btn', 'btn-sm', 'btn-primary', 'me-2');
        saveBtn.innerHTML = 'Save';

        const cancelBtn = document.createElement('button');
        cancelBtn.classList.add('btn', 'btn-sm', 'btn-secondary');
        cancelBtn.innerHTML = 'Cancel';

        buttonsDiv.appendChild(saveBtn);
        buttonsDiv.appendChild(cancelBtn);
        contentDiv.appendChild(buttonsDiv);

        // Auto-adjust textarea height
        adjustTextareaHeight(textarea);
        textarea.focus();

        // Function to re-enable increment controls
        const enableIncrementControls = () => {
          const incrementControls = li.querySelectorAll('.increment-controls .increment-btn');
          incrementControls.forEach(btn => {
            btn.disabled = false;
            btn.classList.remove('disabled');
          });
        };

        // Save changes
        saveBtn.addEventListener('click', () => {
          const newText = textarea.value.trim();
          if (newText !== currentText) {
            if (isTabbed) {
              // Update the specific tab's text
              sentenceObj.tabs[activeTabIndex].text = newText;
              // Rebuild the content to show updated tabs
              contentDiv.innerHTML = '';
              if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
                sentenceObj.tabs.forEach((tab, i) => {
                  contentDiv.appendChild(createTabPaneElement(sentenceObj, i));
                });
              }
            } else {
              // Update regular sentence text
              sentenceObj.text = newText;
              
              // Check if this is an incremental sentence
              const isIncrementalSentence = newText.startsWith('+') || newText.startsWith('++');
              
              if (isIncrementalSentence) {
                // Reset incremental values when text changes to avoid stale data
                sentenceObj.incrementalValues = {};
                
                // Initialize incrementCount if not set
                if (typeof sentenceObj.incrementCount === 'undefined') {
                  sentenceObj.incrementCount = 1;
                }
                
                // Process the incremental text
                let processedText = processIncrementalText(newText, sentenceObj.incrementCount);
                if (processedText) {
                  processedText = processedText.replace(/\\n/g, '<br>');
                }
                
                contentDiv.innerHTML = buildInlineFields(processedText, sentenceObj.values || {}, sentenceObj.incrementalValues);
              } else {
                contentDiv.innerHTML = buildInlineFields(newText, sentenceObj.values || {});
              }
            }

            attachAllEventListenersForElement(contentDiv);
            adjustAllInitialSizesForElement(contentDiv);
            saveState();
          } else {
            contentDiv.innerHTML = originalHTML;
          }
          // Remove editing class and re-enable controls
          contentDiv.classList.remove('editing');
          enableIncrementControls();
        });

        // Cancel editing
        cancelBtn.addEventListener('click', () => {
          contentDiv.innerHTML = originalHTML;
          contentDiv.classList.remove('editing');
          enableIncrementControls();
        });
      });
      return btn;
    }

    function createLockButton(sentenceObj, partLabel) {
      const btn = document.createElement('button');
      btn.classList.add('btn', 'btn-sm', 'lock-sentence-btn');
      btn.title = sentenceObj.locked ? 'Unlock Sentence' : 'Lock Sentence (prevents deletion in New Run)';
      btn.setAttribute('aria-label', sentenceObj.locked ? 'Unlock sentence' : 'Lock sentence');
      btn.innerHTML = `<i class="bi bi-lock${sentenceObj.locked ? '-fill text-primary' : ''}"></i>`;

      btn.addEventListener('click', () => {
        sentenceObj.locked = !sentenceObj.locked;
        // Update button appearance immediately
        btn.title = sentenceObj.locked ? 'Unlock Sentence' : 'Lock Sentence';
        btn.setAttribute('aria-label', sentenceObj.locked ? 'Unlock sentence' : 'Lock sentence');
        btn.innerHTML = `<i class="bi bi-lock${sentenceObj.locked ? '-fill text-primary' : ''}"></i>`;
        saveState(); // Save state when lock status changes
        // No need to rebuild UI just for lock state change if only icon/title changes
      });
      return btn;
    }

    function createIncrementControls(sentenceObj, partLabel) {
      const controlsContainer = document.createElement('div');
      controlsContainer.classList.add('increment-controls', 'd-flex', 'align-items-center');
      
      // Decrement button
      const decrementBtn = document.createElement('button');
      decrementBtn.classList.add('btn', 'btn-sm', 'btn-secondary', 'increment-btn');
      decrementBtn.innerHTML = '<i class="bi bi-dash"></i>';
      decrementBtn.title = 'Decrease count';
      decrementBtn.addEventListener('click', () => {
        if (sentenceObj.incrementCount > 1) {
          sentenceObj.incrementCount--;
          updateIncrementalSentence(sentenceObj, partLabel);
        }
      });
      
      // Count display
      const countDisplay = document.createElement('span');
      countDisplay.classList.add('increment-count', 'mx-2', 'fw-bold');
      countDisplay.textContent = sentenceObj.incrementCount || 1;
      
      // Increment button
      const incrementBtn = document.createElement('button');
      incrementBtn.classList.add('btn', 'btn-sm', 'btn-secondary', 'increment-btn');
      incrementBtn.innerHTML = '<i class="bi bi-plus"></i>';
      incrementBtn.title = 'Increase count';
      incrementBtn.addEventListener('click', () => {
        sentenceObj.incrementCount = (sentenceObj.incrementCount || 1) + 1;
        updateIncrementalSentence(sentenceObj, partLabel);
      });
      
      controlsContainer.appendChild(decrementBtn);
      controlsContainer.appendChild(countDisplay);
      controlsContainer.appendChild(incrementBtn);
      
      return controlsContainer;
    }

    function updateIncrementalSentence(sentenceObj, partLabel) {
      const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
      if (!li) return;
      
      // Store current values before rebuilding - but store them properly for incremental sentences
      const existingIncrementalValues = {};
      
      // Get all fields grouped by label with their index positions
      const fieldsByLabel = {};
      li.querySelectorAll('.sentence-content .inline-field[data-label]').forEach((field, globalIndex) => {
        const label = field.dataset.label;
        if (!fieldsByLabel[label]) {
          fieldsByLabel[label] = [];
        }
        fieldsByLabel[label].push({
          field: field,
          value: field.value,
          index: fieldsByLabel[label].length // This gives us the position within this label group
        });
      });
      
      // Store values in the incremental format - but preserve empty positions
      Object.keys(fieldsByLabel).forEach(label => {
        existingIncrementalValues[label] = fieldsByLabel[label].map(item => item.value);
      });
      
      // Update the count display
      const countDisplay = li.querySelector('.increment-count');
      if (countDisplay) {
        countDisplay.textContent = sentenceObj.incrementCount;
      }
      
      // Update the sentence object's incremental values before rebuilding the UI
      if (!sentenceObj.incrementalValues) {
        sentenceObj.incrementalValues = {};
      }
      
      // Store the current state in incrementalValues
      Object.keys(existingIncrementalValues).forEach(label => {
        sentenceObj.incrementalValues[label] = existingIncrementalValues[label].map(value => 
          (value && value.trim()) ? value : '' // Ensure empty strings for blank fields
        );
      });
      
      // Update the content with the new incremental text
      const contentDiv = li.querySelector('.sentence-content');
      if (contentDiv && sentenceObj.text) {
        let processedText = processIncrementalText(sentenceObj.text, sentenceObj.incrementCount);
        
        // Convert \n to <br> BEFORE calling buildInlineFields
        if (processedText) {
          processedText = processedText.replace(/\\n/g, '<br>');
        }
        
        // Pass incrementalValues to buildInlineFields so existing values are preserved
        contentDiv.innerHTML = buildInlineFields(processedText, sentenceObj.values, sentenceObj.incrementalValues);
        
        // Reattach event listeners for the updated content
        attachAllEventListenersForElement(contentDiv);
        adjustAllInitialSizesForElement(contentDiv);
      }
      
      saveState();
    }

    function processIncrementalText(originalText, count) {
      // Check if this is a ++ (formatted) or + (plain) incremental sentence
      const isFormattedIncremental = originalText.startsWith('++');
      const isPlainIncremental = originalText.startsWith('+') && !originalText.startsWith('++');
      
      // Remove the leading + or ++ if present
      let text = originalText;
      if (isFormattedIncremental) {
        text = originalText.substring(2); // Remove ++
      } else if (isPlainIncremental) {
        text = originalText.substring(1); // Remove +
      } else {
        return originalText; // No incremental markers
      }
      
      // Find incremental content marked with [+content] - need to handle nested brackets properly
      const incrementalMatches = [];
      let match;
      const regex = /\[\+/g;
      
      while ((match = regex.exec(text)) !== null) {
        const startIndex = match.index;
        let bracketCount = 1;
        let endIndex = match.index + match[0].length;
        
        // Find the matching closing bracket, accounting for nested brackets
        while (bracketCount > 0 && endIndex < text.length) {
          if (text[endIndex] === '[') {
            bracketCount++;
          } else if (text[endIndex] === ']') {
            bracketCount--;
          }
          endIndex++;
        }
        
        if (bracketCount === 0) {
          const fullMatch = text.substring(startIndex, endIndex);
          const content = text.substring(startIndex + 2, endIndex - 1); // Remove [+ and ]
          incrementalMatches.push({
            fullMatch,
            content,
            index: startIndex
          });
        }
      }
      
      if (incrementalMatches.length === 0) {
        return text; // No incremental content found
      }
      
      // Process each incremental section (in reverse order to maintain indices)
      let processedText = text;
      
      incrementalMatches.reverse().forEach(matchData => {
        const { fullMatch, content } = matchData;
        
        let repeatedContent;
        
        if (isFormattedIncremental) {
          // ++ sentences: Use proper grammar with Oxford comma and "and"
          if (count === 1) {
            repeatedContent = content;
          } else if (count === 2) {
            repeatedContent = `${content} and ${content}`;
          } else {
            // For 3 or more items: "item, item, and item"
            const items = Array(count).fill(content);
            const lastItem = items.pop();
            repeatedContent = items.join(', ') + ', and ' + lastItem;
          }
        } else if (isPlainIncremental) {
          // + sentences: Just repeat the content with spaces, no formatting added
          repeatedContent = Array(count).fill(content).join(' ');
        }
        
        // Replace the [+content] with the repeated content
        processedText = processedText.replace(fullMatch, repeatedContent);
      });
      
      return processedText;
    }

    function createAddSentenceForm(secObj) {
      const form = document.createElement("form");
      form.classList.add("add-item-form");
      form.dataset.part = secObj.part;
      form.addEventListener('submit', (e) => e.preventDefault()); // Prevent default form submission

      const groupDiv = document.createElement("div");
      groupDiv.classList.add("add-item-group");

      const textarea = document.createElement("textarea");
      textarea.classList.add("form-control", "form-control-sm", "auto-height-textarea");
      textarea.placeholder = "Type to add new sentence or search existing...";
      textarea.setAttribute('aria-label', `Add sentence to ${secObj.part}`);
      textarea.rows = 1; // Start with a single row

      const addBtn = document.createElement("button");
      addBtn.type = "button"; // Important: type="button" to prevent form submission
      addBtn.classList.add("btn", "btn-sm", "btn-secondary");
      addBtn.innerText = "Add";
      addBtn.title = "Add new sentence from text area";

      // Add the missing click event listener for the Add button
      addBtn.addEventListener("click", () => {
        const newText = textarea.value.trim();
        if (newText) {
          addSentence(secObj.part, { text: newText });
          textarea.value = "";
          adjustTextareaHeight(textarea);
          suggestionsBox.style.display = 'none';
        }
      });

      // Add sentence on Enter (but not Shift+Enter for new lines)
      textarea.addEventListener("keypress", (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault(); // Prevent new line
          const newText = textarea.value.trim();
          if (newText) {
            addSentence(secObj.part, { text: newText });
            textarea.value = "";
            adjustTextareaHeight(textarea);
            suggestionsBox.style.display = "none";
          }
        }
      });

      groupDiv.appendChild(textarea);
      groupDiv.appendChild(addBtn);

      // Suggestions Box for autocomplete
      const suggestionsBox = document.createElement("div");
      suggestionsBox.classList.add("suggestions-box");
      const suggestionsUl = document.createElement("ul");
      suggestionsBox.appendChild(suggestionsUl);

      form.appendChild(groupDiv);
      form.appendChild(suggestionsBox);

      // Event listeners for textarea (autocomplete and auto-height)
      textarea.addEventListener("input", () => {
        handleSuggestionsInput(textarea, suggestionsBox, secObj.part);
        adjustTextareaHeight(textarea);
      });
      textarea.addEventListener("blur", () => {
        // Delay hiding suggestions to allow click on a suggestion
        setTimeout(() => { suggestionsBox.style.display = "none"; }, 150);
      });
      return form;
    }

    // --- UI Interaction Functions ---
    function handleSuggestionsInput(inputElement, suggestionsBoxElement, partLabel) {
      const query = inputElement.value.trim();
      const ulEl = suggestionsBoxElement.querySelector("ul");
      if (!ulEl) return;
      ulEl.innerHTML = ""; // Clear previous suggestions

      if (query.length < fuseOptions.minMatchCharLength) {
        suggestionsBoxElement.style.display = "none";
        return;
      }

      const fuseResults = fuse.search(query);
      if (fuseResults.length === 0) {
        suggestionsBoxElement.style.display = "none";
        return;
      }

      fuseResults.slice(0, 10).forEach((res) => { // Show top 10 results
        const li = document.createElement("li");
        
        // Remove leading + from display text
        const displayText = res.item.display.startsWith('+') ? res.item.display.substring(1) : res.item.display;
        li.textContent = displayText;
        li.title = res.item.original;    // Full text on hover

        // Use mousedown for selection to fire before blur on textarea
        li.addEventListener("mousedown", () => {
          addSentence(partLabel, { text: res.item.original });
          inputElement.value = ""; // Clear input
          if (inputElement.tagName === 'TEXTAREA') adjustTextareaHeight(inputElement);
          suggestionsBoxElement.style.display = "none";
        });
        ulEl.appendChild(li);
      });
      suggestionsBoxElement.style.display = "block";
    }

    function addSentence(partLabel, sentenceData) {
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section) { console.error(`Section ${partLabel} not found.`); return; }

      sentenceData.id = "sentence-" + sentenceIdCounter++;
      initializeSentenceValues(sentenceData); // Ensure values are initialized
      if (!section.sentences) section.sentences = [];
      section.sentences.push(sentenceData);
      if (DEBUG) console.log(`Sentence added: ${sentenceData.id} to ${partLabel}`);

      const ul = document.querySelector(`.sentence-list[data-part="${partLabel}"]`);
      if (ul) {
        const li = createSentenceElement(sentenceData, partLabel);
        ul.appendChild(li);
        // Attach listeners and adjust sizes for the new element specifically
        attachAllEventListenersForElement(li);
        adjustAllInitialSizesForElement(li);
        li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } else {
        // Fallback: if UL not found (should not happen if structure is correct), rebuild
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }
      saveState();
    }

    function addSentenceAtIndex(partLabel, sentenceData, index) {
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section) { console.error(`Section ${partLabel} not found.`); return; }

      sentenceData.id = "sentence-" + sentenceIdCounter++;
      initializeSentenceValues(sentenceData);
      if (!section.sentences) section.sentences = [];
      
      // Insert at the specified index (clamped to valid range)
      const insertIndex = Math.min(index, section.sentences.length);
      section.sentences.splice(insertIndex, 0, sentenceData);
      if (DEBUG) console.log(`Sentence added at index ${insertIndex}: ${sentenceData.id} to ${partLabel}`);

      const ul = document.querySelector(`.sentence-list[data-part="${partLabel}"]`);
      if (ul) {
        const li = createSentenceElement(sentenceData, partLabel);
        
        // Get direct children only (not nested li elements)
        const existingItems = ul.children;
        
        // Safely insert at the correct position
        if (existingItems.length > 0 && insertIndex < existingItems.length) {
          const referenceNode = existingItems[insertIndex];
          if (referenceNode && referenceNode.parentNode === ul) {
            ul.insertBefore(li, referenceNode);
          } else {
            ul.appendChild(li);
          }
        } else {
          ul.appendChild(li);
        }
        
        attachAllEventListenersForElement(li);
        adjustAllInitialSizesForElement(li);
        li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } else {
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }
      saveState();
    }

    function removeSentence(partLabel, sentenceId) {
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section || !section.sentences) return;

      const index = section.sentences.findIndex(s => s.id === sentenceId);
      if (index > -1) {
        section.sentences.splice(index, 1);
        if (DEBUG) console.log(`Sentence data removed: ${sentenceId}`);
        const li = document.querySelector(`li[data-id="${sentenceId}"]`);
        if (li) {
          li.remove();
          if (DEBUG) console.log(`Sentence DOM element removed: ${sentenceId}`);
        } else { // Fallback if DOM element somehow not found
          buildSectionsUI();
          attachAllEventListeners();
          adjustAllInitialSizes();
        }
        saveState();
      } else {
        console.warn(`Sentence ID ${sentenceId} not found in section ${partLabel} data.`);
      }
    }

    function switchTab(sentenceId, tabIndex) {
      const sentenceObj = findSentenceById(sentenceId);
      if (!sentenceObj || !sentenceObj.tabs) return;
      if (tabIndex < 0 || tabIndex >= sentenceObj.tabs.length) return;

      const li = document.querySelector(`li[data-id="${sentenceId}"]`);
      if (!li) return;

      // Check if currently in edit mode - prevent tab switching
      const contentDiv = li.querySelector('.sentence-content');
      if (contentDiv && contentDiv.classList.contains('editing')) {
        if (DEBUG) console.log('Cannot switch tabs while editing. Please save or cancel your changes first.');
        showConfirmationModal(
          "Edit in Progress",
          "Please save or cancel your current changes before switching tabs.",
          "",
          () => { },
          () => { },
          true
        );
        return;
      }

      sentenceObj.activeTabIndex = tabIndex;
      if (DEBUG) console.log(`Switched to tab ${tabIndex} for sentence ${sentenceId}`);

      if (li) {
        // Update tab button active states
        const tabButtons = li.querySelectorAll('.tabs-container .tab-button');
        tabButtons.forEach((btn, index) => btn.classList.toggle('active', index === tabIndex));

        // Update tab pane active states and content
        const tabPanes = li.querySelectorAll('.sentence-content .tab-pane');
        tabPanes.forEach((pane, index) => {
          const isActive = index === tabIndex;
          pane.classList.toggle('active', isActive);
          if (isActive) {
            // Rebuild content for the newly active tab
            const tabContent = sentenceObj.tabs[index].text || "";
            const tabValues = sentenceObj.tabValues[index] || {};
            pane.innerHTML = buildInlineFields(tabContent, tabValues);
            // Re-attach listeners and adjust sizes for the new content in the active tab
            attachAllEventListenersForElement(pane);
            adjustAllInitialSizesForElement(pane);
          }
        });
      } else { // Fallback if sentence <li> not found
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }
      saveState();
    }


    // --- Input Value Handling (Saving on Blur) ---
    function attachBlurListeners() {
      const container = document.getElementById('sectionContainer');
      if (!container) return;
      // Use event delegation for blur on inline fields
      container.removeEventListener('blur', handleInlineFieldBlurDelegated, true); // Remove previous if any
      container.addEventListener('blur', handleInlineFieldBlurDelegated, true); // Capture phase
    }
    function attachBlurListenersForElement(element) {
      // For dynamically added elements, attach directly if delegation isn't covering it
      element.querySelectorAll('.inline-field[data-label]').forEach(field => {
        field.removeEventListener('blur', handleInlineFieldBlur); // Prevent duplicates
        field.addEventListener('blur', handleInlineFieldBlur);
      });
    }

    function handleInlineFieldBlurDelegated(event) {
      if (event.target.matches('.inline-field[data-label]')) {
        handleInlineFieldBlur(event);
      }
    }
    function handleInlineFieldBlur(event) {
      const field = event.target;
      const label = field.dataset.label;
      const value = field.value;
      const li = field.closest('li[data-id]');
      if (!li || !label) return;

      const sentenceId = li.dataset.id;
      const sentenceObj = findSentenceById(sentenceId);
      if (!sentenceObj) return;

      const tabPane = field.closest('.tab-pane[data-tab-index]');
      let valueChanged = false;

      if (tabPane) { // Value is within a tab
        const tabIndex = parseInt(tabPane.dataset.tabIndex);
        if (!isNaN(tabIndex) && sentenceObj.tabValues?.[tabIndex]) {
          if (sentenceObj.tabValues[tabIndex][label] !== value) {
            sentenceObj.tabValues[tabIndex][label] = value;
            valueChanged = true;
          }
        }
      } else if (sentenceObj.values) { // Value is in a non-tabbed sentence
        // Check if this is an incremental sentence with multiple instances of the same field
        const isIncremental = sentenceObj.text && (sentenceObj.text.startsWith('+') || sentenceObj.text.startsWith('++'));
        
        if (isIncremental) {
          // For incremental sentences, store values as arrays
          const allFieldsWithSameLabel = li.querySelectorAll(`.sentence-content > .inline-field[data-label="${label}"]`);
          const fieldIndex = Array.from(allFieldsWithSameLabel).indexOf(field);
          
          if (!sentenceObj.incrementalValues) sentenceObj.incrementalValues = {};
          if (!sentenceObj.incrementalValues[label]) sentenceObj.incrementalValues[label] = [];
          
          if (sentenceObj.incrementalValues[label][fieldIndex] !== value) {
            sentenceObj.incrementalValues[label][fieldIndex] = value;
            valueChanged = true;
          }
        } else {
          // Regular non-incremental sentence
          if (sentenceObj.values[label] !== value) {
            sentenceObj.values[label] = value;
            valueChanged = true;
          }
        }
      }
      
      // Remove empty field highlighting when value is entered
      if (value && value.trim() !== '') {
        field.classList.remove('empty-field');
      }
      
      if (valueChanged) {
        if (DEBUG) console.log(`Value saved for ${sentenceId} - ${label}: ${value}`);
        saveState();
        
        // Remove placeholder check on blur - only check when generating text
      }
    }

    /** Stores all inline field values into the JS data structure. Called before generation. */
    function storeAllInlineValues() {
      let changesMade = false;
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
          if (!li) return; // Skip if DOM element not found

          initializeSentenceValues(sentenceObj); // Ensure value objects exist

          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            sentenceObj.tabs.forEach((tab, tabIndex) => {
              const tabPane = li.querySelector(`.tab-pane[data-tab-index="${tabIndex}"]`);
              if (!tabPane) return;
              if (!sentenceObj.tabValues[tabIndex]) sentenceObj.tabValues[tabIndex] = {}; // Should be initialized already

              tabPane.querySelectorAll(".inline-field[data-label]").forEach(field => {
                const label = field.dataset.label;
                const newValue = field.value;
                if (sentenceObj.tabValues[tabIndex][label] !== newValue) {
                  sentenceObj.tabValues[tabIndex][label] = newValue;
                  changesMade = true;
                }
              });
            });
          } else { // Non-tabbed sentence
            if (!sentenceObj.values) sentenceObj.values = {}; // Should be initialized already
            
            // Check if this is an incremental sentence
            const isIncremental = sentenceObj.text && (sentenceObj.text.startsWith('+') || sentenceObj.text.startsWith('++'));
            
            if (isIncremental) {
              // For incremental sentences, store values as arrays in incrementalValues
              if (!sentenceObj.incrementalValues) sentenceObj.incrementalValues = {};
              
              // Group fields by label
              const fieldsByLabel = {};
              li.querySelectorAll(".sentence-content .inline-field[data-label]").forEach((field) => {
                const label = field.dataset.label;
                if (!fieldsByLabel[label]) {
                  fieldsByLabel[label] = [];
                }
                fieldsByLabel[label].push(field.value);
              });
              
              // Store the values in incrementalValues
              Object.keys(fieldsByLabel).forEach(label => {
                const currentValues = sentenceObj.incrementalValues[label] || [];
                const newValues = fieldsByLabel[label];
                
                // Check if values have changed - compare arrays element by element
                const hasChanged = currentValues.length !== newValues.length ||
                  newValues.some((val, idx) => val !== currentValues[idx]);
                
                if (hasChanged) {
                  sentenceObj.incrementalValues[label] = newValues;
                  changesMade = true;
                }
              });
            } else {
              // Regular non-incremental sentence
              li.querySelectorAll(".sentence-content > .inline-field[data-label]").forEach(field => {
                // Ensure we only get direct children of sentence-content, not those inside tab-panes if any mix-up
                const label = field.dataset.label;
                const newValue = field.value;
                if (sentenceObj.values[label] !== newValue) {
                  sentenceObj.values[label] = newValue;
                  changesMade = true;
                }
              });
            }
          }
        });
      });
      if (changesMade) console.log("Stored all inline values, changes detected.");
      return changesMade;
    }


    // --- HTML Building for Inline Fields ---
    function buildInlineFields(textTemplate, valuesObject, incrementalValuesObject) {
      if (!valuesObject) valuesObject = {}; // Ensure valuesObject is an object
      if (!incrementalValuesObject) incrementalValuesObject = {}; // For incremental sentences
      
      let displayText = textTemplate || "";
      
      // If there are no placeholders in the text, return as-is (no more \n conversion needed)
      if (!placeholderRegex.test(displayText)) {
        return displayText;
      }
      
      // Track placeholder counts for incremental sentences
      const placeholderCounts = {};
    
      const processedText = displayText.replace(placeholderRegex, (match, type, label, options) => {
        // For incremental sentences, track how many times we've seen each placeholder
        if (!placeholderCounts[label]) {
          placeholderCounts[label] = 0;
        }
        const currentIndex = placeholderCounts[label];
        placeholderCounts[label]++;
        
        // Get value: first try incrementalValues array, then fall back to regular values
        let currentValue = "";
        if (incrementalValuesObject[label] && Array.isArray(incrementalValuesObject[label])) {
          currentValue = incrementalValuesObject[label][currentIndex] || "";
        } else {
          currentValue = valuesObject[label] || "";
        }
        
        let dropdownOptionsArray = [];
    
        if (options) { // Options defined directly in template
          dropdownOptionsArray = options.split(",").map(x => x.trim());
        } else if (globalDropdownOptions[label]) { // Options from global config
          dropdownOptionsArray = globalDropdownOptions[label];
        }
    
        switch (type) {
          case "customDropdown":
            const listItems = dropdownOptionsArray.map(opt => {
              const isHidden = opt.startsWith(HIDDEN_ITEM_MARKER);
              const displayOpt = isHidden ? opt.substring(HIDDEN_ITEM_MARKER.length) : opt;
              const hiddenAttr = isHidden ? ' data-hidden="true"' : '';
              return `<li class="list-group-item"${hiddenAttr} title="${displayOpt}">${displayOpt}</li>`;
            }).join("");
            return `
            <div class="custom-dropdown">
              <input type="text" class="inline-field custom-dropdown-input" data-type="customDropdown" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocomplete="off" autocapitalize="off"/>
              <div class="suggestions">
                <ul class="list-group">${listItems}</ul>
              </div>
            </div>`;
          case "text":
            // Keep the original value (with \n) for the input field
            return `<input type="text" class="inline-field" data-type="text" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocapitalize="off"/>`;
          case "number":
            return `<input type="number" class="inline-field" data-type="number" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocapitalize="off"/>`;
          case "dropdown":
            console.warn(`Standard 'dropdown' type encountered for [${label}]. Consider using 'customDropdown' for richer features or ensure specific handling is implemented if needed.`);
            return `<input type="text" class="inline-field" data-type="dropdown" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocomplete="off" autocapitalize="off"/>`;
          default:
            console.warn(`Unknown placeholder type: ${type} for label: ${label}`);
            return match;
        }
      });
    
      return processedText;
    }

    // --- Drag and Drop ---
    function makeSentencesDraggable() {
      const lists = document.querySelectorAll(".sentence-list");
      lists.forEach(ul => {
        // Destroy existing Sortable instance if present, to avoid duplicates
        const existingSortable = Sortable.get(ul);
        if (existingSortable) {
          existingSortable.destroy();
        }
        new Sortable(ul, {
          animation: 150,
          group: { name: "narrativeGroup", pull: true, put: true }, // Allow dragging between lists
          handle: ".drag-handle", // Specify drag handle
          ghostClass: "sortable-ghost",  // Class for the drop placeholder
          chosenClass: "sortable-chosen", // Class for the chosen item
          dragClass: "sortable-drag",    // Class for the dragging item
          onEnd: handleDragEnd,
        });
      });
    }

    function handleDragEnd(evt) {
      const itemEl = evt.item; // The dragged element
      const sentenceId = itemEl.dataset.id;
      const toListEl = evt.to;   // List element where item was dropped
      const fromListEl = evt.from; // List element from where item was dragged
      const oldIndex = evt.oldDraggableIndex; // Original index in old list
      const newIndex = evt.newDraggableIndex; // New index in new list

      const toPartLabel = toListEl.dataset.part;
      const fromPartLabel = fromListEl.dataset.part;

      if (DEBUG) console.log(`Sentence ${sentenceId} moved from ${fromPartLabel}[${oldIndex}] to ${toPartLabel}[${newIndex}]`);

      // Find the sentence object in our JavaScript data
      const fromSection = narrativeSections.find(s => s.part === fromPartLabel);
      if (!fromSection || !fromSection.sentences) { console.error("Source section data not found."); return; }

      // Remove sentence from old location in data
      const [movedSentence] = fromSection.sentences.splice(oldIndex, 1);
      if (!movedSentence || movedSentence.id !== sentenceId) {
        console.error("Sentence data mismatch during drag operation. Rebuilding UI to prevent data corruption.");
        // Critical error, rebuild UI from current (potentially slightly off) state to be safe
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
        return;
      }

      // Add sentence to new location in data
      const toSection = narrativeSections.find(s => s.part === toPartLabel);
      if (!toSection) {
        console.error("Target section data not found. Reverting move.");
        fromSection.sentences.splice(oldIndex, 0, movedSentence); // Put it back
        // Rebuild UI as a fallback
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
        return;
      }
      if (!toSection.sentences) toSection.sentences = [];
      toSection.sentences.splice(newIndex, 0, movedSentence);

      // Update the dataset.part on the DOM element if it moved to a new section
      if (fromPartLabel !== toPartLabel) {
        itemEl.dataset.part = toPartLabel;
      }

      saveState(); // Save the new order/location
      // No need to rebuild UI if SortableJS handles DOM update, unless cross-list styling changes.
    }

    // --- Custom Dropdown Logic ---
    function attachDropdownLogic() {
      const container = document.getElementById('sectionContainer');
      if (!container) return;

      // Focus: Show/filter suggestions
      container.removeEventListener('focusin', handleDropdownFocusDelegated); // Use focusin for better delegation
      container.addEventListener('focusin', handleDropdownFocusDelegated);

      // Input: Filter suggestions dynamically
      container.removeEventListener('input', handleDropdownInputDelegated);
      container.addEventListener('input', handleDropdownInputDelegated);

      // Keydown: Navigate suggestions, select, escape
      container.removeEventListener('keydown', handleDropdownKeydownDelegated);
      container.addEventListener('keydown', handleDropdownKeydownDelegated);

      // Mousedown on suggestion: Select item (use mousedown to fire before blur)
      container.removeEventListener('mousedown', handleDropdownSuggestionClickDelegated);
      container.addEventListener('mousedown', handleDropdownSuggestionClickDelegated);

      // Blur: Hide suggestions (with delay)
      container.removeEventListener('focusout', handleDropdownBlurDelegated); // Use focusout
      container.addEventListener('focusout', handleDropdownBlurDelegated);
    }

    function attachDropdownLogicForElement(element) {
      const dropdownInputs = element.matches('.custom-dropdown-input') ? [element] : element.querySelectorAll(".custom-dropdown-input");
      dropdownInputs.forEach(input => {
        const dropdownContainer = input.closest('.custom-dropdown');
        if (!dropdownContainer) return;
        const suggestionBox = dropdownContainer.querySelector(".suggestions");
        if (!suggestionBox) return;

        input.removeEventListener('focus', handleDropdownFocusDirect); input.addEventListener('focus', handleDropdownFocusDirect);
        input.removeEventListener('input', handleDropdownInputDirect); input.addEventListener('input', handleDropdownInputDirect);
        input.removeEventListener('keydown', handleDropdownKeydownDirect); input.addEventListener('keydown', handleDropdownKeydownDirect);
        // Click/mousedown on suggestions is handled by delegation on suggestionBox or its parent
        suggestionBox.removeEventListener('mousedown', handleDropdownSuggestionClickDirect); // Attach to suggestionBox
        suggestionBox.addEventListener('mousedown', handleDropdownSuggestionClickDirect);
        input.removeEventListener('blur', handleDropdownBlurDirect); input.addEventListener('blur', handleDropdownBlurDirect);
      });
    }

    // Delegated handlers
    function handleDropdownFocusDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownInputDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownKeydownDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) processDropdownKeydown(event.target, event);
    }
    function handleDropdownSuggestionClickDelegated(event) {
      if (event.target.matches('.custom-dropdown .suggestions li')) {
        const input = event.target.closest('.custom-dropdown')?.querySelector('.custom-dropdown-input');
        if (input) {
          selectDropdownItem(input, event.target);
          hideDropdownSuggestions(input); // Hide after selection
          // Manually trigger blur's save logic for the input field
          handleInlineFieldBlur({ target: input });
        }
      }
    }
    function handleDropdownBlurDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) {
        // Check if the relatedTarget (where focus went) is part of the suggestions
        const dropdownContainer = event.target.closest('.custom-dropdown');
        const suggestionBox = dropdownContainer?.querySelector('.suggestions');
        if (suggestionBox && suggestionBox.contains(event.relatedTarget)) {
          return; // Don't hide if focus moved to a suggestion
        }
        processDropdownBlur(event.target);
      }
    }

    // Direct handlers (for dynamically added elements if delegation is tricky)
    function handleDropdownFocusDirect(event) {
      filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownInputDirect(event) {
      filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownKeydownDirect(event) {
      processDropdownKeydown(event.target, event);
    }
    function handleDropdownSuggestionClickDirect(event) { // Attached to suggestionBox
      if (event.target.matches('li')) { // Check if a list item was clicked
        const input = event.currentTarget.closest('.custom-dropdown')?.querySelector('.custom-dropdown-input');
        if (input) {
          selectDropdownItem(input, event.target);
          hideDropdownSuggestions(input);
          handleInlineFieldBlur({ target: input });
        }
      }
    }
    function handleDropdownBlurDirect(event) {
      const dropdownContainer = event.target.closest('.custom-dropdown');
      const suggestionBox = dropdownContainer?.querySelector('.suggestions');
      if (suggestionBox && suggestionBox.contains(document.activeElement) && document.activeElement !== event.target) {
        // If focus is now on a suggestion item, don't hide yet.
        // The click on the suggestion will handle hiding.
        return;
      }
      processDropdownBlur(event.target);
    }

    /** Filters suggestions based on input, handles hidden items, positions and shows dropdown. (NEW/REVISED) */
    function filterAndShowDropdownSuggestions(inputElement) {
      const dropdownContainer = inputElement.closest('.custom-dropdown');
      const suggestionBox = dropdownContainer?.querySelector(".suggestions");
      const liAncestor = inputElement.closest('li'); // Position relative to the LI
      if (!suggestionBox || !liAncestor) {
        console.error("Cannot find suggestions box or list item for input:", inputElement);
        return;
      }

      const filterText = inputElement.value.toLowerCase().trim();
      const items = Array.from(suggestionBox.querySelectorAll("li"));
      let hasVisibleItems = false;

      items.forEach(item => {
        const itemText = item.textContent.toLowerCase();
        const isHiddenByDefault = item.dataset.hidden === 'true';

        // Determine visibility based on filter text
        let shouldShow = true;
        if (filterText) {
          // If filtering, show if text matches (hidden status doesn't matter)
          shouldShow = itemText.includes(filterText);
        } else {
          // If not filtering (just focused), hide items marked as hidden
          shouldShow = !isHiddenByDefault;
        }

        item.style.display = shouldShow ? "" : "none";
        if (shouldShow) {
          hasVisibleItems = true;
        }
      });

      // Only show the box if there are items to display
      if (hasVisibleItems) {
        positionDropdownSuggestions(inputElement, suggestionBox, liAncestor);
        suggestionBox.style.display = "block";
        highlightDropdownItem(items.filter(li => li.style.display !== 'none'), -1); // Reset highlight on filter/show
      } else {
        suggestionBox.style.display = "none";
      }
    }

    function positionDropdownSuggestions(inputElement, suggestionBox, liAncestor) {
      const inputRect = inputElement.getBoundingClientRect();

      // Position relative to the viewport
      suggestionBox.style.position = 'fixed'; // Use fixed positioning for viewport coordinates
      suggestionBox.style.left = `${inputRect.left}px`;
      suggestionBox.style.top = `${inputRect.bottom + 2}px`; // 2px gap below input
      suggestionBox.style.minWidth = `${inputRect.width}px`;
      suggestionBox.style.maxWidth = `350px`; // Max width constraint
      suggestionBox.style.zIndex = '1000'; // Ensure it appears above other content

      // Store reference to the input element on the suggestion box for repositioning during scroll
      suggestionBox.dataset.linkedInputId = inputElement.id || '';

      // If input doesn't have an ID, create one so we can reference it later
      if (!inputElement.id) {
        inputElement.id = 'dropdown-input-' + Math.random().toString(36).substring(2, 10);
        suggestionBox.dataset.linkedInputId = inputElement.id;
      }

      // Add this dropdown to the active dropdowns collection if it's not already tracked
      if (suggestionBox.style.display !== 'none' && !activeDropdowns.includes(suggestionBox)) {
        activeDropdowns.push(suggestionBox);

        // Ensure scroll listener is attached if this is the first visible dropdown
        if (activeDropdowns.length === 1) {
          window.addEventListener('scroll', handleScrollForDropdowns, { passive: true });
        }
      }

      // Use requestAnimationFrame to ensure styles are applied and dimensions are available
      requestAnimationFrame(() => {
        const suggestionsRect = suggestionBox.getBoundingClientRect();

        // Check if dropdown extends beyond viewport bottom
        if (suggestionsRect.bottom > window.innerHeight) {
          const spaceAbove = inputRect.top; // Space above input in viewport

          if (suggestionsRect.height < spaceAbove) {
            // If it fits above the input, position it above
            suggestionBox.style.top = `${inputRect.top - suggestionsRect.height - 2}px`;
          } else {
            // Otherwise, position at bottom with a max-height constraint
            const maxHeight = window.innerHeight - inputRect.bottom - 10; // 10px from bottom of viewport
            suggestionBox.style.maxHeight = `${maxHeight}px`;
            suggestionBox.style.overflowY = 'auto';
          }
        }

        // Check if dropdown extends beyond viewport right edge
        if (suggestionsRect.right > window.innerWidth) {
          suggestionBox.style.left = `${window.innerWidth - suggestionsRect.width - 5}px`; // 5px padding from right edge
        }

        // Check if dropdown extends beyond viewport left edge
        if (suggestionsRect.left < 0) {
          suggestionBox.style.left = '5px'; // 5px padding from left edge
        }
      });
    }

    function processDropdownKeydown(inputElement, event) {
      const suggestionBox = inputElement.closest('.custom-dropdown')?.querySelector(".suggestions");
      if (!suggestionBox || suggestionBox.style.display === 'none') return;

      const visibleItems = Array.from(suggestionBox.querySelectorAll("li:not([style*='display: none'])"));
      if (visibleItems.length === 0 && event.key !== 'Escape') return; // Allow Escape even if no items

      let focusedIndex = visibleItems.findIndex(item => item.classList.contains('highlight'));

      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          focusedIndex = (focusedIndex <= 0) ? visibleItems.length - 1 : focusedIndex - 1;
          highlightDropdownItem(visibleItems, focusedIndex);
          break;
        case 'ArrowDown':
          event.preventDefault();
          focusedIndex = (focusedIndex < 0 || focusedIndex >= visibleItems.length - 1) ? 0 : focusedIndex + 1;
          highlightDropdownItem(visibleItems, focusedIndex);
          break;
        case 'Enter':
        case 'Tab': // Treat Tab like Enter for selection if an item is highlighted
          if (focusedIndex >= 0 && focusedIndex < visibleItems.length) {
            event.preventDefault();
            selectDropdownItem(inputElement, visibleItems[focusedIndex]);
            hideDropdownSuggestions(inputElement);
            handleInlineFieldBlur({ target: inputElement }); // Ensure save
          } else if (event.key === 'Enter') { // If Enter but no selection, just hide
            event.preventDefault();
            hideDropdownSuggestions(inputElement);
            // inputElement.blur(); // Optionally blur
          }
          // Allow Tab to function normally if no item is highlighted
          break;
        case 'Escape':
          event.preventDefault();
          hideDropdownSuggestions(inputElement);
          break;
      }
    }

    function highlightDropdownItem(visibleItems, index) {
      const suggestionBox = visibleItems[0]?.closest('.suggestions');
      if (suggestionBox) { // Remove from all items in this specific dropdown
        suggestionBox.querySelectorAll("li").forEach(item => item.classList.remove("highlight"));
      }
      if (index >= 0 && index < visibleItems.length) {
        visibleItems[index].classList.add("highlight");
        visibleItems[index].scrollIntoView({ block: 'nearest', inline: 'nearest' });
      }
    }

    function selectDropdownItem(inputElement, selectedLi) {
      inputElement.value = selectedLi.textContent.trim();
      inputElement.title = inputElement.value; // Update title attribute
      adjustInputWidth(inputElement); // Adjust width based on new value
      // The blur handler (handleInlineFieldBlur) will save the state.
      // It's triggered by the click handler or after Enter/Tab.
    }

    function hideDropdownSuggestions(inputElement) {
      const suggestionBox = inputElement.closest('.custom-dropdown')?.querySelector(".suggestions");
      if (suggestionBox) {
        suggestionBox.style.display = "none";
        highlightDropdownItem(Array.from(suggestionBox.querySelectorAll("li")), -1); // Clear highlight

        // Remove from active dropdowns when hidden
        const index = activeDropdowns.indexOf(suggestionBox);
        if (index !== -1) {
          activeDropdowns.splice(index, 1);

          // Remove scroll listener if no active dropdowns remain
          if (activeDropdowns.length === 0) {
            window.removeEventListener('scroll', handleScrollForDropdowns);
          }
        }
      }
    }

    function processDropdownBlur(inputElement) {
      // Delay hiding to allow click on suggestion to register
      setTimeout(() => {
        // Check if focus has moved to an element *within the same custom dropdown's suggestions*
        const dropdownContainer = inputElement.closest('.custom-dropdown');
        const suggestionBox = dropdownContainer?.querySelector('.suggestions');
        const activeElement = document.activeElement;

        // If the new active element is a child of this suggestion box, don't hide.
        // The click on the suggestion will handle selection and hiding.
        if (suggestionBox && suggestionBox.contains(activeElement)) {
          return;
        }
        hideDropdownSuggestions(inputElement);
        // The main blur handler (handleInlineFieldBlur) attached to the input will save its value.
      }, 150);
    }

    function handleScrollForDropdowns() {
      // If no active dropdowns, remove the scroll listener
      if (activeDropdowns.length === 0) {
        window.removeEventListener('scroll', handleScrollForDropdowns);
        return;
      }

      // Process each active dropdown
      activeDropdowns.forEach((suggestionBox, index) => {
        // Skip if dropdown is no longer in DOM or is hidden
        if (!document.body.contains(suggestionBox) || suggestionBox.style.display === 'none') {
          activeDropdowns.splice(index, 1);
          return;
        }

        // Get the linked input element
        const inputId = suggestionBox.dataset.linkedInputId;
        if (!inputId) return;

        const inputElement = document.getElementById(inputId);
        if (!inputElement) return;

        // Get the li ancestor for context
        const liAncestor = inputElement.closest('li[data-id]');
        if (!liAncestor) return;

        // Reposition the dropdown based on new scroll position
        positionDropdownSuggestions(inputElement, suggestionBox, liAncestor);
      });
    }


    // --- Final Text Generation ---
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const finalTextArea = document.getElementById("finalText");
      const changesDetected = storeAllInlineValues(); // Capture all current input values

      // Fix: Re-implement overwrite confirmation when the final text area has content
      if (finalTextArea.value.trim() !== "") {
        showConfirmationModal(
          "Generate Text",
          "This will overwrite the current text in the final narrative area. Continue?",
          "",
          () => generateAndDisplayText(finalTextArea), // Yes callback
          () => { } // No callback (do nothing)
        );
      } else {
        // If textarea is empty, generate immediately without confirmation
        generateAndDisplayText(finalTextArea);
      }
    });

    // --- Validate Button ---
    document.getElementById("validateBtn").addEventListener("click", () => {
      storeAllInlineValues(); // Capture all current input values
      
      const hasEmptyFields = checkForEmptyPlaceholders();
      const hasUnaddedSentences = checkForUnaddedSentences();
      
      showPlaceholderWarning(hasEmptyFields);
      showUnaddedSentenceWarning(hasUnaddedSentences);
      
      if (!hasEmptyFields && !hasUnaddedSentences) {
        showConfirmationModal(
          "Validation Passed",
          "All fields are filled and all sentences have been added.",
          "",
          () => {},
          () => {},
          true // single button (OK)
        );
      }
    });

    /**
     * Generates the final text with information about locked sentences
     * @returns {Array} [finalText, hasLockedSentences, lockedSectionsInfo, lockedSentencesCount]
     */
    function generateFinalTextWithLockInfo() {
      let finalTextParts = [];
      let hasLockedSentences = false;
      let lockedSentencesCount = 0;
      let lockedSectionsInfo = [];

      // Fix: Get the state of the "Include Section Titles" checkbox
      const includeSectionTitles = document.getElementById("toggleSectionTitles")?.checked || false;

      narrativeSections.forEach(section => {
        if (!section.sentences || section.sentences.length === 0) return;

        let sectionHasLockedSentence = false;
        let sectionText = '';

        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.locked) {
            sectionHasLockedSentence = true;
            hasLockedSentences = true;
            lockedSentencesCount++;
          }

          let processedText;
          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            // For tabbed sentences, use the active tab's text
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const tabText = sentenceObj.tabs[activeTabIndex].text || "";
              const tabValues = sentenceObj.tabValues?.[activeTabIndex] || {};
              processedText = processSentence(tabText, tabValues);
            } else {
              processedText = "";
            }
          } else {
            // For non-tabbed sentences
            processedText = processSentence(sentenceObj.text || "", sentenceObj.values || {});
          }

          if (processedText.trim()) {
            sectionText += processedText.trim() + " ";
          }
        });

        if (sectionText.trim()) {
          // Include section titles when checkbox is checked
          if (includeSectionTitles) {
            finalTextParts.push(`${section.part}:\n${sectionText.trim()}`);
          } else {
            finalTextParts.push(sectionText.trim());
          }

          if (sectionHasLockedSentence) {
            lockedSectionsInfo.push(section.part);
          }
        }
      });

      return [finalTextParts.join("\n\n"), hasLockedSentences, lockedSectionsInfo, lockedSentencesCount];
    }

    /**
     * Generates and displays the final text
     * @param {HTMLElement} finalTextArea - The text area to display the text in
     */
    function generateAndDisplayText(finalTextArea) {
      try {
        const [finalText, hasLockedSentences, lockedSectionsInfo, lockedSentencesCount] = generateFinalTextWithLockInfo();
        finalTextArea.value = finalText;

        // Track Receiving Facility values in the background
        trackReceivingFacilities();

        // If there are locked sentences, show an indicator
        const copyLockedInfoEl = document.getElementById('copyLockedInfo') || createCopyLockedInfoElement();
        if (hasLockedSentences) {
          const sentenceText = lockedSentencesCount === 1 ? 'sentence' : 'sentences';
          copyLockedInfoEl.innerHTML = `<i class="bi bi-lock-fill text-primary"></i> ${lockedSentencesCount} locked ${sentenceText}`;
          copyLockedInfoEl.style.display = 'block';
          copyLockedInfoEl.title = `Sections with locked content: ${lockedSectionsInfo.join(', ')}`;
        } else {
          copyLockedInfoEl.style.display = 'none';
        }

        // Only check for empty placeholders when generating text
        const hasEmptyFields = checkForEmptyPlaceholders();
        showPlaceholderWarning(hasEmptyFields);

        // Check for unadded sentences in add sentence textareas
        const hasUnaddedSentences = checkForUnaddedSentences();
        showUnaddedSentenceWarning(hasUnaddedSentences);
      } catch (error) {
        console.error("Error generating final text:", error);
        showConfirmationModal("Error", "Failed to generate text. Please check console for details.", "", () => { }, () => { }, true);
      }
    }

    /**
     * Tracks and sends Receiving Facility values to the API
     */
    function trackReceivingFacilities() {
      const receivingFacilities = new Set(); // Use Set to automatically handle duplicates
      
      // Search through all narrative sections for Receiving Facility values
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        
        section.sentences.forEach(sentenceObj => {
          // Handle tabbed sentences
          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            sentenceObj.tabValues.forEach((tabValues, tabIndex) => {
              if (tabValues && tabValues['Receiving Facility']) {
                const facilityValue = tabValues['Receiving Facility'].trim();
                if (facilityValue && facilityValue !== '[Receiving Facility]') {
                  receivingFacilities.add(facilityValue);
                }
              }
            });
          } 
          // Handle non-tabbed sentences
          else if (sentenceObj.values && sentenceObj.values['Receiving Facility']) {
            const facilityValue = sentenceObj.values['Receiving Facility'].trim();
            if (facilityValue && facilityValue !== '[Receiving Facility]') {
              receivingFacilities.add(facilityValue);
            }
          }
        });
      });
      
      // Send each unique facility value to the API
      receivingFacilities.forEach(facility => {
        sendFacilityToAPI(facility);
      });
      
      if (receivingFacilities.size > 0) {
        if (DEBUG) console.log(`Tracked ${receivingFacilities.size} unique receiving facilities:`, Array.from(receivingFacilities));
      }
    }

    /**
     * Sends a receiving facility value to the API
     * @param {string} facilityName - The name of the receiving facility
     */
    async function sendFacilityToAPI(facilityName) {
      try {
        const payload = {
          type: 'receiving_facility',
          facility_name: facilityName,
          timestamp: new Date().toISOString(),
          user_agent: navigator.userAgent,
          config_name: currentConfigName
        };
        
        const response = await fetch('https://api.bbrown.access.ly/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          if (DEBUG) console.log(`Successfully tracked facility: ${facilityName}`, result);
        } else {
          console.warn(`Failed to track facility: ${facilityName}. Status: ${response.status}`);
        }
      } catch (error) {
        // Fail silently for tracking - don't interrupt user experience
        console.warn(`Error tracking facility "${facilityName}":`, error);
      }
    }

    /**
     * Creates an info element for displaying locked sentence information
     */
    function createCopyLockedInfoElement() {
      const infoEl = document.createElement('div');
      infoEl.id = 'copyLockedInfo';
      infoEl.classList.add('copy-locked-info', 'text-muted', 'small', 'mt-2');

      // Insert after final text area
      const finalTextArea = document.getElementById('finalText');
      finalTextArea.parentNode.insertBefore(infoEl, finalTextArea.nextSibling);

      return infoEl;
    }

    /**
     * Process a sentence by replacing placeholders with values
     * Fix: Show [placeholder] when values are empty or missing
     * Also handle line breaks properly in final output
     */
    function processSentence(text, values) {
      if (!text) return "";
      if (!values) values = {};

      let processedText = text;

      // Remove leading + or ++ markers for final output
      if (processedText.startsWith('++')) {
        processedText = processedText.substring(2);
      } else if (processedText.startsWith('+')) {
        processedText = processedText.substring(1);
      }

      // For incremental sentences, we need to find the sentence object to get incrementalValues
      // This is a bit of a hack, but we need to identify if this is an incremental sentence
      const isIncremental = text.startsWith('+') || text.startsWith('++');
      
      if (isIncremental) {
        // Find the sentence object that matches this text to get incremental values
        let sentenceObj = null;
        for (const section of narrativeSections) {
          if (!section.sentences) continue;
          for (const sentence of section.sentences) {
            if (sentence.text === text) {
              sentenceObj = sentence;
              break;
            }
          }
          if (sentenceObj) break;
        }
        
        if (sentenceObj && sentenceObj.incrementalValues) {
          // Process incremental text first to get the expanded version
          processedText = processIncrementalText(text, sentenceObj.incrementCount);
          
          // Remove the leading markers again after processing
          if (processedText.startsWith('++')) {
            processedText = processedText.substring(2);
          } else if (processedText.startsWith('+')) {
            processedText = processedText.substring(1);
          }
          
          // Remove [+content] markers
          processedText = processedText.replace(/\[\+([^\[\]]*(?:\[[^\]]*\][^\[\]]*)*)\]/g, '$1');
          
          // Replace placeholders with incremental values
          const placeholderCounts = {};
          processedText = processedText.replace(placeholderRegex, (match, type, label) => {
            // Track how many times we've seen this placeholder
            if (!placeholderCounts[label]) {
              placeholderCounts[label] = 0;
            }
            
            const index = placeholderCounts[label];
            placeholderCounts[label]++;
            
            // Get the value for this specific instance
            const incrementalValues = sentenceObj.incrementalValues[label];
            if (incrementalValues && incrementalValues[index] && incrementalValues[index].trim()) {
              return incrementalValues[index].trim();
            } else {
              return `[${label}]`;
            }
          });
        } else {
          // Fallback for incremental sentences without proper incrementalValues
          processedText = processedText.replace(/\[\+([^\[\]]*(?:\[[^\]]*\][^\[\]]*)*)\]/g, '$1');
          processedText = processedText.replace(placeholderRegex, (match, type, label) => {
            const value = values[label];
            return (value && value.toString().trim()) ? value.toString().trim() : `[${label}]`;
          });
        }
      } else {
        // Regular non-incremental sentence processing
        processedText = processedText.replace(/\[\+([^\[\]]*(?:\[[^\]]*\][^\[\]]*)*)\]/g, '$1');
        processedText = processedText.replace(placeholderRegex, (match, type, label) => {
          const value = values[label];
          return (value && value.toString().trim()) ? value.toString().trim() : `[${label}]`;
        });
      }

      // Convert \n to actual line breaks in final output for copying/exporting
      processedText = processedText.replace(/\\n/g, '\n');
      
      return processedText;
    }

    // --- Button Event Listeners ---
    document.getElementById("copyBtn").addEventListener("click", () => {
      const finalTextArea = document.getElementById("finalText");
      const textToCopy = finalTextArea.value.trim();
      if (!textToCopy) {
        showConfirmationModal("Copy", "Nothing to copy!", "", () => { }, () => { }, true);
        return;
      }
      navigator.clipboard.writeText("\u200B" + textToCopy).then(() => {
        if (DEBUG) console.log("Text copied to clipboard.");
        showConfirmationModal("Copied to Clipboard",
          "The final narrative has been copied to the clipboard.<br><br>Would you like to start a new run?",
          // Fix: Use HTML for disclaimer to properly render the <br> tag
          "<span>Paste your narrative first,</span><br><span>unlocked sentences will be reset to their default values.</span>",
          () => {
            if (DEBUG) console.log("Final narrative area cleared after copy and confirmation.");
            // Clear the final text area
            finalTextArea.value = '';
            // Reset all sentences to current config defaults
            resetToCurrentConfigDefaults();
            // Clear the placeholder warning
            showPlaceholderWarning(false);
            // Clear the locked sentences info
            const copyLockedInfoEl = document.getElementById('copyLockedInfo');
            if (copyLockedInfoEl) {
              copyLockedInfoEl.style.display = 'none';
            }
          },
          () => { },
          false, // Not single button
          true // Show lock toggle
        );
      }).catch(err => {
        console.error("Copy to clipboard failed: ", err);
        showConfirmationModal("Copy Failed", "Could not copy text to clipboard. Your browser might not support this feature or has restrictions.", "", () => { }, () => { }, true);
      });
    });

    /**
     * Checks for empty placeholder values in all sentences by examining actual placeholders in text
     * @returns {boolean} True if any empty placeholder values are found
     */
    function checkForEmptyPlaceholders() {
      let hasEmptyFields = false;

      narrativeSections.forEach(section => {
        if (!section.sentences) return;

        section.sentences.forEach(sentenceObj => {
          // Check for empty values in regular sentences
          if (!sentenceObj.tabs) {
            const text = sentenceObj.text || "";
            const isIncremental = text.startsWith('+') || text.startsWith('++');
            
            if (isIncremental) {
              // For incremental sentences, check incrementalValues
              const incrementalValues = sentenceObj.incrementalValues || {};
              const incrementCount = sentenceObj.incrementCount || 1;
              
              // Process the text to expand it based on increment count
              const expandedText = processIncrementalText(text, incrementCount);
              
              // Find all placeholders in the expanded text
              const placeholderMatches = [...expandedText.matchAll(placeholderRegex)];
              
              // Track how many times we've seen each label
              const labelCounts = {};
              
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                if (!labelCounts[label]) labelCounts[label] = 0;
                const index = labelCounts[label];
                labelCounts[label]++;
                
                // Check if this specific instance has a value
                const valuesArray = incrementalValues[label] || [];
                const value = valuesArray[index];
                if (!value || value.trim() === '') {
                  hasEmptyFields = true;
                }
              });
            } else {
              // Regular non-incremental sentence
              const values = sentenceObj.values || {};
              
              // Find all placeholders in the text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = values[label];
                if (!value || value.trim() === '') {
                  hasEmptyFields = true;
                }
              });
            }
          } else {
            // For tabbed sentences, only check the ACTIVE tab
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const activeTab = sentenceObj.tabs[activeTabIndex];
              const text = activeTab.text || "";
              const tabValues = sentenceObj.tabValues[activeTabIndex] || {};
              
              // Find all placeholders in the active tab's text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = tabValues[label];
                if (!value || value.trim() === '') {
                  hasEmptyFields = true;
                }
              });
            }
          }
        });
      });

      return hasEmptyFields;
    }

    /**
     * Highlights empty placeholder fields in the UI
     * @param {boolean} highlight Whether to add or remove highlighting
     */
    function highlightEmptyFields(highlight = true) {
      // Remove existing highlights first
      document.querySelectorAll('.inline-field.empty-field').forEach(field => {
        field.classList.remove('empty-field');
      });

      if (!highlight) return;

      narrativeSections.forEach(section => {
        if (!section.sentences) return;

        section.sentences.forEach(sentenceObj => {
          const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
          if (!li) return;

          // Check for empty values in regular sentences
          if (!sentenceObj.tabs) {
            const text = sentenceObj.text || "";
            const isIncremental = text.startsWith('+') || text.startsWith('++');
            
            if (isIncremental) {
              // For incremental sentences, check incrementalValues and highlight ALL empty fields
              const incrementalValues = sentenceObj.incrementalValues || {};
              
              // Get all inline fields in this sentence, grouped by label
              const allFields = li.querySelectorAll(`.sentence-content .inline-field[data-label]`);
              const fieldsByLabel = {};
              
              allFields.forEach((field, index) => {
                const label = field.dataset.label;
                if (!fieldsByLabel[label]) fieldsByLabel[label] = [];
                fieldsByLabel[label].push(field);
              });
              
              // Check each field instance
              Object.keys(fieldsByLabel).forEach(label => {
                const fields = fieldsByLabel[label];
                const valuesArray = incrementalValues[label] || [];
                
                fields.forEach((field, index) => {
                  const value = valuesArray[index];
                  if (!value || value.trim() === '') {
                    field.classList.add('empty-field');
                  }
                });
              });
            } else {
              // Regular non-incremental sentence
              const values = sentenceObj.values || {};
              
              // Find all placeholders in the text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = values[label];
                if (!value || value.trim() === '') {
                  // Find and highlight the corresponding input field
                  const field = li.querySelector(`.inline-field[data-label="${label}"]:not(.tab-pane .inline-field)`);
                  if (field) {
                    field.classList.add('empty-field');
                  }
                }
              });
            }
          } else {
            // For tabbed sentences, only check the ACTIVE tab
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const activeTab = sentenceObj.tabs[activeTabIndex];
              const text = activeTab.text || "";
              const tabValues = sentenceObj.tabValues[activeTabIndex] || {};
              
              // Find all placeholders in the active tab's text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = tabValues[label];
                if (!value || value.trim() === '') {
                  // Find and highlight the corresponding input field in the active tab
                  const tabPane = li.querySelector(`.tab-pane[data-tab-index="${activeTabIndex}"]`);
                  if (tabPane) {
                    const field = tabPane.querySelector(`.inline-field[data-label="${label}"]`);
                    if (field) {
                      field.classList.add('empty-field');
                    }
                  }
                }
              });
            }
          }
        });
      });
    }

    /**
     * Shows or hides the placeholder warning and highlights empty fields
     * @param {boolean} show Whether to show the warning
     */
    function showPlaceholderWarning(show) {
      const finalTextArea = document.getElementById("finalText");
      const warningContainer = document.getElementById("placeholderWarningContainer") || createWarningElement();

      if (show) {
        finalTextArea.classList.add("has-empty-placeholders");
        warningContainer.style.display = "block";
        highlightEmptyFields(true);
      } else {
        finalTextArea.classList.remove("has-empty-placeholders");
        warningContainer.style.display = "none";
        highlightEmptyFields(false);
      }
    }

    /**
     * Creates the warning element if it doesn't exist
     * @returns {HTMLElement} The warning container element
     */
    function createWarningElement() {
      const finalTextArea = document.getElementById("finalText");
      const finalTextContainer = finalTextArea.parentElement;

      const warningContainer = document.createElement("div");
      warningContainer.id = "placeholderWarningContainer";
      warningContainer.classList.add("placeholder-warning", "text-danger");
      warningContainer.innerHTML = '<i class="bi bi-exclamation-triangle-fill"></i> Warning: Some placeholder values remain!';

      // Insert before the textarea
      finalTextContainer.insertBefore(warningContainer, finalTextArea);
      return warningContainer;
    }

    /**
     * Checks for any unadded sentences in add sentence textareas
     * @returns {boolean} True if any add sentence textareas have content
     */
    function checkForUnaddedSentences() {
      const addSentenceTextareas = document.querySelectorAll('.add-item-form textarea');
      for (const textarea of addSentenceTextareas) {
        if (textarea.value.trim() !== '') {
          return true;
        }
      }
      return false;
    }

    /**
     * Creates the unadded sentence warning element if it doesn't exist
     * @returns {HTMLElement} The warning container element
     */
    function createUnaddedWarningElement() {
      // Check if element already exists to prevent duplicates
      const existingElement = document.getElementById("unaddedSentenceWarningContainer");
      if (existingElement) {
        return existingElement;
      }

      const finalTextArea = document.getElementById("finalText");
      const finalTextContainer = finalTextArea.parentElement;

      const warningContainer = document.createElement("div");
      warningContainer.id = "unaddedSentenceWarningContainer";
      warningContainer.classList.add("placeholder-warning", "text-danger");
      warningContainer.innerHTML = '<i class="bi bi-exclamation-triangle-fill"></i> Warning: Some sentences have not been added!';

      // Insert before the textarea
      finalTextContainer.insertBefore(warningContainer, finalTextArea);
      return warningContainer;
    }

    /**
     * Shows or hides the unadded sentence warning
     * @param {boolean} show Whether to show the warning
     */
    function showUnaddedSentenceWarning(show) {
      const warningContainer = document.getElementById("unaddedSentenceWarningContainer") || createUnaddedWarningElement();

      if (show) {
        warningContainer.style.display = "block";
      } else {
        warningContainer.style.display = "none";
      }
    }

    // --- Utility Functions ---
    function findSentenceById(id) {
      for (const sec of narrativeSections) {
        if (!sec.sentences) continue;
        const sentence = sec.sentences.find(s => s.id === id);
        if (sentence) return sentence;
      }
      console.warn(`Sentence with ID ${id} not found in any section.`);
      return null;
    }

    // --- Input Auto-Sizing ---
    function attachInputSizingListeners() {
      const container = document.getElementById('sectionContainer');
      if (container) {
        // Use event delegation for efficiency
        container.removeEventListener('input', handleAutoSizingInputDelegated);
        container.addEventListener('input', handleAutoSizingInputDelegated);
      }
    }
    function attachInputSizingListenersForElement(element) {
      element.querySelectorAll('.inline-field, .auto-height-textarea').forEach(input => {
        input.removeEventListener('input', handleAutoSizingInputDirect); // Prevent duplicates
        input.addEventListener('input', handleAutoSizingInputDirect);
      });
    }

    function handleAutoSizingInputDelegated(event) {
      if (event.target.matches('.inline-field')) adjustInputWidth(event.target);
      else if (event.target.matches('.auto-height-textarea')) adjustTextareaHeight(event.target);
    }
    function handleAutoSizingInputDirect(event) { // For dynamically added elements
      if (event.target.matches('.inline-field')) adjustInputWidth(event.target);
      else if (event.target.matches('.auto-height-textarea')) adjustTextareaHeight(event.target);
    }

    function adjustTextareaHeight(textarea) {
      if (!textarea) return;
      textarea.style.height = 'auto'; // Temporarily shrink to get scrollHeight
      const newHeight = Math.max(textarea.scrollHeight, parseFloat(getComputedStyle(textarea).minHeight) || 0);
      textarea.style.height = `${newHeight}px`;
    }

    function adjustInputWidth(input) {
      if (!input || !widthMeasurerSpan) return;
      const inputStyle = window.getComputedStyle(input);
      const isCustomDropdown = input.classList.contains('custom-dropdown-input');
      // Use a slightly larger base min-width for custom dropdowns to accommodate potential dropdown arrows or icons if added later
      const minWidth = parseFloat(inputStyle.minWidth) || (isCustomDropdown ? 80 : MIN_INLINE_WIDTH);

      widthMeasurerSpan.style.font = inputStyle.font;
      widthMeasurerSpan.textContent = input.placeholder || ' '; // Measure placeholder width
      const placeholderWidth = widthMeasurerSpan.scrollWidth;
      widthMeasurerSpan.textContent = input.value || ' '; // Measure value width
      const valueWidth = widthMeasurerSpan.scrollWidth;

      // Add a small buffer (e.g., 2-5px) to prevent text from touching the edge
      const contentWidthBuffer = 5;
      const requiredContentWidth = Math.max(valueWidth, placeholderWidth) + contentWidthBuffer;

      const parentLi = input.closest('li[data-id]'); // Get parent list item
      let parentWidth = parentLi?.clientWidth || window.innerWidth; // Fallback to window width
      // Reduce available parent width slightly to account for padding/margins on the LI or controls
      parentWidth = parentWidth * 0.9;

      let maxWidth = parentWidth * (MAX_INLINE_WIDTH_PERCENT / 100);
      maxWidth = Math.max(maxWidth, minWidth * 1.5); // Ensure max width is at least 1.5x min width

      const newWidth = Math.min(maxWidth, Math.max(minWidth, requiredContentWidth));
      input.style.width = `${newWidth}px`;
    }

    function adjustAllInitialSizes() {
      document.querySelectorAll('.inline-field').forEach(input => adjustInputWidth(input));
      document.querySelectorAll('.auto-height-textarea').forEach(textarea => adjustTextareaHeight(textarea));
    }
    function adjustAllInitialSizesForElement(element) {
      element.querySelectorAll('.inline-field').forEach(input => adjustInputWidth(input));
      element.querySelectorAll('.auto-height-textarea').forEach(textarea => adjustTextareaHeight(textarea));
    }


    // --- Modal Dialog ---
    function showConfirmationModal(title, message, disclaimer, callbackYes, callbackNo, singleButton = false, showLockToggle = false) {
      const modalEl = document.getElementById("confirmationModal");
      if (!modalEl) { console.error("Confirmation modal element not found!"); return; }

      const modalLabel = modalEl.querySelector("#confirmationModalLabel");
      const modalBody = modalEl.querySelector("#confirmationModalBody");
      const modalDisclaimer = modalEl.querySelector("#confirmationDisclaimer");
      const yesBtn = modalEl.querySelector("#confirmYesBtn");
      const noBtn = modalEl.querySelector("#confirmNoBtn");
      const lockToggleBtn = modalEl.querySelector("#confirmationLockToggle");

      if (!modalLabel || !modalBody || !modalDisclaimer || !yesBtn || !noBtn || !lockToggleBtn) {
        console.error("One or more modal sub-elements not found!");
        return;
      }
      const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);

      modalLabel.textContent = title || "Confirmation";
      modalBody.innerHTML = message || ""; // Use innerHTML to allow for <br> etc.

      // Fix: Use innerHTML for disclaimer to properly render HTML content if needed
      modalDisclaimer.innerHTML = disclaimer || "";

      yesBtn.style.display = singleButton ? 'none' : 'inline-block';
      noBtn.textContent = singleButton ? 'OK' : 'No';

      // Show/hide lock toggle button based on parameter
      lockToggleBtn.style.display = showLockToggle ? 'inline-block' : 'none';
      
      // Initialize lock toggle state (locked by default)
      let unlockLockedSentences = false;
      if (showLockToggle) {
        lockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
        lockToggleBtn.title = 'Click to also reset locked sentences';
        lockToggleBtn.classList.remove('btn-warning');
        lockToggleBtn.classList.add('btn-outline-secondary');
      }

      // Remove previous listeners before adding new ones to prevent multiple calls
      const newYesBtn = yesBtn.cloneNode(true);
      yesBtn.parentNode.replaceChild(newYesBtn, yesBtn);
      const newNoBtn = noBtn.cloneNode(true);
      noBtn.parentNode.replaceChild(newNoBtn, noBtn);
      const newLockToggleBtn = lockToggleBtn.cloneNode(true);
      lockToggleBtn.parentNode.replaceChild(newLockToggleBtn, lockToggleBtn);

      newYesBtn.style.display = singleButton ? 'none' : 'inline-block';
      newNoBtn.textContent = singleButton ? 'OK' : 'No';
      newLockToggleBtn.style.display = showLockToggle ? 'inline-block' : 'none';

      // Lock toggle functionality
      if (showLockToggle) {
        newLockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
        newLockToggleBtn.title = 'Click to also reset locked sentences';
        newLockToggleBtn.classList.remove('btn-warning');
        newLockToggleBtn.classList.add('btn-outline-secondary');

        newLockToggleBtn.addEventListener('click', () => {
          unlockLockedSentences = !unlockLockedSentences;
          if (unlockLockedSentences) {
            newLockToggleBtn.innerHTML = '<i class="bi bi-unlock-fill"></i>';
            newLockToggleBtn.title = 'Will reset locked sentences';
            newLockToggleBtn.classList.remove('btn-outline-secondary');
            newLockToggleBtn.classList.add('btn-danger');
          } else {
            newLockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
            newLockToggleBtn.title = 'Click to also reset locked sentences';
            newLockToggleBtn.classList.remove('btn-danger');
            newLockToggleBtn.classList.add('btn-outline-secondary');
          }
        });
      }

      newYesBtn.addEventListener('click', () => {
        bsModal.hide();
        if (callbackYes && typeof callbackYes === 'function') {
          // If unlock toggle was enabled and activated, unlock all sentences first
          if (showLockToggle && unlockLockedSentences) {
            unlockAllSentences();
          }
          callbackYes();
        }
      });
      newNoBtn.addEventListener('click', () => {
        bsModal.hide();
        if (callbackNo && typeof callbackNo === 'function') callbackNo();
      });
      bsModal.show();
    }

    // Function to unlock all locked sentences
    function unlockAllSentences() {
      let unlockedCount = 0;
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.locked) {
            sentenceObj.locked = false;
            unlockedCount++;
          }
        });
      });
      if (DEBUG) console.log(`Unlocked ${unlockedCount} sentences`);
      saveState(); // Save the unlocked state
    }

    // Bug Report initialization function
    function initializeBugReport() {
      if (DEBUG) console.log("Initializing bug report functionality...");
      const bugReportBtn = document.getElementById('bugReportBtn');
      const bugReportModalEl = document.getElementById('bugReportModal');

      if (!bugReportBtn || !bugReportModalEl) {
        console.error("Bug report button or modal not found!");
        return;
      }

      // Update the icon to use the solid version
      if (bugReportBtn.querySelector('i')) {
        bugReportBtn.querySelector('i').className = 'bi bi-bug-fill';
      }

      const bugReportModal = new bootstrap.Modal(bugReportModalEl);

      // Add click event to show the modal
      bugReportBtn.addEventListener('click', () => {
        bugReportModal.show();
      });

      // Setup submit button functionality
      const submitBugBtn = document.getElementById('submitBug');
      if (submitBugBtn) {
        submitBugBtn.addEventListener('click', () => {
          const desc = document.getElementById('bugDescription').value;
          if (desc.trim()) {
            // Encode the bug description for URL
            const encodedDescription = encodeURIComponent(desc.trim());

            // Construct the Google Forms URL with the bug report
            const formUrl = `https://docs.google.com/forms/d/e/1FAIpQLSfiovEazZnz0HhEULNqjiyrbC6CyhPi0MVd7qWeJvKUTWoBIA/formResponse?submit=Submit&usp=pp_url&entry.1588653800=${encodedDescription}`;

            // Open the form in a new tab
            window.open(formUrl, '_blank');

            // Clear the textarea and hide the modal
            document.getElementById('bugDescription').value = '';
            bugReportModal.hide();

            // Show confirmation message
            showConfirmationModal(
              "Bug Report Submitted",
              "Thank you for your bug report!",
              "",
              () => { },
              () => { },
              true
            );
          } else {
            // Show error if description is empty
            showConfirmationModal(
              "Bug Report",
              "Please enter a description of the bug before submitting.",
              "",
              () => { },
              () => { },
              true
            );
          }
        });
      }

      if (DEBUG) console.log("Bug report functionality initialized.");
    }
  </script>
</body>

</html>
