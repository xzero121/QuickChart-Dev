<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickChart</title>

  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
</head>

<body>
  <span id="width-measurer"></span>

  <div class="container">
    <div class="d-flex align-items-center justify-content-between mb-4 header-bar">
      <h1 class="m-0">
        <img src="QuickChartLogoWide.svg" alt="QuickChart" class="img-fluid"
          style="max-width: 200px; height: auto; vertical-align: middle; margin-right: 0.5em;"
          onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';" />
        <span style="display:none;">QuickChart</span>
      </h1>
      <div class="d-flex align-items-center">
        <button id="bugReportBtn" class="btn btn-outline-primary me-3" title="Report an issue">
          <i class="bi bi-bug-fill"></i>
        </button>
        <h3 class="m-0 fst-italic fw-bold text-danger">Beta Version</h3>
        <button id="darkModeToggle" class="btn btn-outline-secondary ms-3" title="Toggle dark/light mode">
          <i class="bi bi-moon-fill"></i>
        </button>
      </div>
      <div class="header-right">
        <div class="input-group" id="jsonFileInputGroup" style="max-width: 400px;">
          <input type="text" id="jsonFileInput" class="form-control form-control-sm"
            placeholder="Config Name (e.g., default)" value="default"
            title="Enter configuration name (e.g., default, trauma) and click Load">
          <button id="loadJsonBtn" class="btn btn-primary btn-sm">Load</button>
        </div>
        <div class="toggle-newrun-row">
          <div class="form-check form-switch" title="Toggle inclusion of section titles in the final narrative">
            <input class="form-check-input" type="checkbox" id="toggleSectionTitles" checked>
            <label class="form-check-label" for="toggleSectionTitles">
              Output Section Titles
            </label>
          </div>
          <button id="newRunBtn" class="btn btn-warning btn-sm"
            title="Clear the current narrative and start over with the loaded configuration's defaults">New Run</button>
        </div>
      </div>
    </div>

    <div id="sectionContainer">
    </div>

    <button id="generateBtn" class="btn btn-primary mb-3" title="Generate the final narrative text below">Generate Final
      Text</button>

    <div class="mb-3">
      <label for="finalText" class="form-label fw-bold">Final Narrative</label>
      <textarea class="form-control" id="finalText" rows="6"
        placeholder="Generated narrative will appear here..."></textarea>
    </div>

    <button id="copyBtn" class="btn btn-success mb-5" title="Copy the generated narrative to the clipboard">Copy to
      Clipboard</button>

    <div id="disclaimer" class="alert alert-secondary py-1 text-center small" role="alert">
      <strong>Disclaimer:</strong> Data is stored in your browser's local storage. Clearing browser data will remove
      saved narrative. No PHI is sent to a server.
    </div>
    <div id="license" class="alert alert-light py-1 text-center small" role="alert"
      xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
      <a property="dct:title" rel="cc:attributionURL" href="https://xzero121.github.io/QuickChart/">QuickChart</a> by
      <span property="cc:attributionName">B. Brown, EMT-B</span> is licensed under
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/?ref=chooser-v1" target="_blank"
        rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-ND 4.0
        <img class="cc-icon" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"
          alt="CC icon"><img class="cc-icon"
          src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt="BY icon"><img
          class="cc-icon" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"
          alt="NC icon"><img class="cc-icon"
          src="https://mirrors.creativecommons.org/presskit/icons/nd.svg?ref=chooser-v1" alt="ND icon">
      </a>
    </div>
  </div>
  <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="confirmationModalLabel">Confirmation</h5>
          <div class="d-flex align-items-center">
            <button type="button" class="btn btn-sm btn-outline-secondary me-2" id="confirmationLockToggle" 
                    title="Toggle: Reset locked sentences" style="display: none;">
              <i class="bi bi-lock-fill"></i>
            </button>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
        </div>
        <div class="modal-body" id="confirmationModalBody">
        </div>
        <div class="modal-footer d-flex align-items-center justify-content-between">
          <div id="confirmationDisclaimer" class="text-muted small">
          </div>
          <div>
            <button type="button" class="btn btn-primary" id="confirmYesBtn">Yes</button>
            <button type="button" class="btn btn-secondary" id="confirmNoBtn" data-bs-dismiss="modal">No</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="bugReportModal" tabindex="-1" aria-labelledby="bugReportModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="bugReportModalLabel">Report an Issue</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <textarea id="bugDescription" class="form-control" rows="4" placeholder="Describe the issue..."></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="submitBug">Submit</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // --- Constants ---
    const placeholderRegex = /\[(text|number|dropdown|customDropdown):([^:\]]+)(?::([^:\]]+))?\]/g;
    const LOCAL_STORAGE_KEY = 'QuickChart-Beta';
    const MIN_INLINE_WIDTH = 50; // Min width for inline fields (px)
    const MAX_INLINE_WIDTH_PERCENT = 80; // Max width relative to parent (%)
    const DEFAULT_CONFIG_NAME = 'default'; // Default config file name
    const HIDDEN_ITEM_MARKER = '*'; // Prefix for dropdown options hidden by default

    // --- Global State ---
    let rawCommonSentences = [];
    let commonSentences = [];
    let globalDropdownOptions = {};
    let defaultNarrativeSections = []; // Holds the *defaults* from the loaded JSON
    let narrativeSections = []; // Holds the *current working state* (potentially modified by user)
    let fuse;
    let sentenceIdCounter = 1;
    let widthMeasurerSpan; // Ref to hidden span for width calc
    let currentConfigName = DEFAULT_CONFIG_NAME; // Track currently loaded config
    let activeDropdowns = []; // Track visible dropdown suggestion boxes

    // --- Fuse.js Options ---
    const fuseOptions = {
      keys: ["display", "searchable"],
      includeMatches: true,
      threshold: 0.1,
      minMatchCharLength: 2,
      ignoreLocation: true
    };

    // --- Functions ---
    // initializeTooltips();
    // initializeApp();
    // attachAllEventListeners();
    // attachAllEventListenersForElement();
    // attachHeaderListeners();
    // loadConfiguration();
    // loadState();
    // saveState();
    // resetToCurrentConfigDefaults();
    // assignInitialIDs();
    // initializedarkMode();
    // findHighestSentenceId();
    // initializeSentenceValues();
    // shortPlaceholderString();
    // expandedPlaceholderString();
    // buildSectionsUI();
    // createSectionElement();
    // createSentenceElement();
    // createTabsContainer();
    // createTabPaneElement();
    // createRemoveButton();
    // createEditButton();
    // createLockButton();
    // createAddSentenceForm();
    // handleSuggestionsInput();
    // addSentence();
    // removeSentence();
    // switchTab();
    // attachBlurListeners();
    // attachBlurListenersForElement();
    // handleInlineFieldBlurDelegated();
    // handleInlineFieldBlur();
    // storeAllInlineValues();
    // buildInlineFields();
    // makeSentencesDraggable();
    // handleDragEnd();
    // attachDropdownLogic();
    // attachDropdownLogicForElement();
    // handleDropdownFocusDelegated();
    // handleDropdownInputDelegated();
    // handleDropdownKeydownDelegated();
    // handleDropdownSuggestionClick();
    // handleDropdownBlurDelegated();
    // handleDropdownFocusDirect();
    // handleDropdownInputDirect();
    // handleDropdownKeydownDirect();
    // handleDropdownSuggestionClickDirect();
    // handleDropdownBlurDirect();
    // filterAndShowDropdownSuggestions();
    // positionDropdownSuggestions();
    // processDropdownKeydown();
    // highlightDropdownItem();
    // selectDropdownItem();
    // hideDropdownSuggestions();
    // processDropdownBlur();
    // handleScrollForDropdown();
    // generateAndDisplayText();
    // createCopyLockedInfoElement();
    // generateFiunalTextWithLockInfo();
    // processSentence();
    // checkForEmptyPlaceholders();
    // showPlaceholderWarning();
    // createWarningElement();
    // debounce();
    // renderSectionText();
    // FindSentenceById();
    // attachInputSizingListeners();
    // attachInputSizingListenersForElement();
    // handleAutoSizingInputDelegated();
    // HandleAutoSizingInputDirect();
    // adjustTextareaHeight();
    // adjustInputWidth();
    // adjustAllInitialSizes();
    // adjustAllInitialSizesForElement();
    // showConfirmationModal();
    // initializeBugReport();


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function () {
      initializeApp();
    });

    function initializeTooltips() {
      const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
      tooltipTriggerList.map(function (tooltipTriggerEl) {
        if (!bootstrap.Tooltip.getInstance(tooltipTriggerEl)) {
          return new bootstrap.Tooltip(tooltipTriggerEl);
        }
        return null;
      });
      console.log("Tooltips initialized.");
    }

    async function initializeApp() {
      console.log("Initializing QuickChart...");
      widthMeasurerSpan = document.getElementById('width-measurer');
      if (!widthMeasurerSpan) console.error("Width measurer span not found!");

      attachHeaderListeners();
      initializeDarkMode(); // Add dark mode initialization
      initializeBugReport(); // Initialize bug report functionality

      try {
        const savedConfigName = localStorage.getItem("QuickChart-Beta-Config");
        if (!savedConfigName) {
          console.warn("No saved configuration name found. Using default.");
          await loadConfiguration(DEFAULT_CONFIG_NAME, true);
        } else {
          console.log(`Loaded saved configuration name: ${savedConfigName}`);
          await loadConfiguration(savedConfigName, true);
        }
        loadState();
        buildSectionsUI();
        initializeTooltips();
        attachAllEventListeners(); // Consolidated event listener attachment
        adjustAllInitialSizes();

        // Remove initial placeholder check - only check when generating text
        console.log("QuickChart Initialized Successfully.");
      } catch (err) {
        console.error("Failed to initialize QuickChart:", err);
        showConfirmationModal("Initialization Error", `Could not load initial configuration. Please check console or refresh. Error: ${err.message}`, "", () => { }, () => { }, true);
        document.getElementById('sectionContainer').innerHTML = '<p class="text-danger">Error loading configuration.</p>';
      }
    }

    function attachAllEventListeners() {
      attachInputSizingListeners();
      attachBlurListeners();
      attachDropdownLogic();
    }

    function attachAllEventListenersForElement(element) {
      attachInputSizingListenersForElement(element);
      attachBlurListenersForElement(element);
      attachDropdownLogicForElement(element);
    }


    /** Attaches event listeners to header elements */
    function attachHeaderListeners() {
      const loadBtn = document.getElementById('loadJsonBtn');
      const fileInput = document.getElementById('jsonFileInput');
      const newRunBtn = document.getElementById('newRunBtn');

      // Attach event listeners to the load button and file input
      if (loadBtn && fileInput) {
        loadBtn.addEventListener('click', () => {
          const configName = fileInput.value.trim() || DEFAULT_CONFIG_NAME;
          showConfirmationModal(
            `Load Configuration: ${configName}?`,
            `Loading '${configName}' will discard your current narrative and replace it with the defaults from that configuration. Continue?`,
            "Your work will not be saved.",
            () => {
              const modalEl = document.getElementById("confirmationModal");
              // Use a one-time event listener for when the modal is hidden
              modalEl.addEventListener('hidden.bs.modal', async function handler() {
                modalEl.removeEventListener('hidden.bs.modal', handler); // Clean up
                await loadConfiguration(configName);
                resetToCurrentConfigDefaults(); // This will rebuild UI and reattach listeners
              }, { once: true });
            },
            () => { } // User cancelled
          );
        });
        fileInput.addEventListener("keypress", (e) => {
          if (e.key === 'Enter') { e.preventDefault(); loadBtn.click(); }
        });
      } else { console.error("Load button or file input not found."); }

      // Attach event listener to the new run button
      if (newRunBtn) {
        newRunBtn.addEventListener('click', () => {
          showConfirmationModal(
            "Start New Run",
            `This will discard changes and reset to the defaults for the '${currentConfigName}' configuration. Continue?`,
            "",
            () => resetToCurrentConfigDefaults(), // This will rebuild UI and reattach listeners
            () => { }, // User cancelled
            false, // Not single button
            true // Show lock toggle
          );
        });
      } else { console.error("New Run button not found."); }
    }

    async function loadConfiguration(configName, isInitialLoad = false) {
      const filename = `${configName.toLowerCase()}.json`;

      console.log(`Attempting to load configuration: ${filename}`);
      try {
        const response = await fetch(filename);
        if (!response.ok) {
          throw new Error(`Configuration file '${filename}' not found or could not be loaded (Status: ${response.status})`);
        }
        const data = await response.json();

        // Save the loaded config name to localStorage
        if (!isInitialLoad) {
          try {
            localStorage.setItem("QuickChart-Beta-Config", configName);
          } catch (e) {
            console.error("Failed to save config name.", e);
          }
        }


        rawCommonSentences = data.commonSentences || [];
        globalDropdownOptions = data.globalDropdownOptions || {};
        defaultNarrativeSections = data.narrativeSections || [];

        // Assign stable IDs on defaultNarrativeSections so locks persist across resets
        assignInitialIDs(defaultNarrativeSections);

        commonSentences = rawCommonSentences.map((s) => ({
          original: s,
          display: shortPlaceholderString(s),
          searchable: expandedPlaceholderString(s),
        }));
        fuse = new Fuse(commonSentences, fuseOptions);

        currentConfigName = configName;
        document.getElementById('jsonFileInput').value = configName;

        if (!isInitialLoad) {
          showConfirmationModal("Load Successful", `Configuration '${configName}' loaded successfully.`, "", () => { }, () => { }, true);
        }
        console.log(`Configuration '${configName}' loaded.`);
      } catch (error) {
        console.error(`Failed to load or parse configuration '${filename}':`, error);
        showConfirmationModal("Load Error", `Could not load configuration '${configName}'. Please check the name and ensure the file exists. <br><small>(${error.message})</small>`, "", () => { }, () => { }, true);
        document.getElementById('jsonFileInput').value = currentConfigName;
        throw error;
      }
    }

    // --- State Management ---
    function loadState() {
      const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (savedState) {
        try {
          let loadedState = JSON.parse(savedState);

          // If there was previously saved state, merge locked sentences with defaults
          // to ensure locked status persists through refresh
          const lockedSentenceMap = new Map();

          // First, identify all locked sentences from the loaded state
          loadedState.forEach(section => {
            if (!section.sentences) return;
            section.sentences.forEach(s => {
              if (s.locked && s.id) {
                lockedSentenceMap.set(s.id, {
                  text: s.text,
                  values: s.values ? { ...s.values } : {},
                  tabValues: s.tabValues ? JSON.parse(JSON.stringify(s.tabValues)) : [],
                  activeTabIndex: s.activeTabIndex,
                  locked: true
                });
              }
            });
          });

          // Set narrative sections to loaded state
          narrativeSections = loadedState;

          // Ensure locked state is preserved even if IDs get reassigned
          if (lockedSentenceMap.size > 0) {
            assignInitialIDs(narrativeSections);

            // Re-apply locked status and content to matching sentences
            narrativeSections.forEach(section => {
              if (!section.sentences) return;
              section.sentences.forEach(s => {
                if (lockedSentenceMap.has(s.id)) {
                  const lockedData = lockedSentenceMap.get(s.id);
                  s.locked = true;
                  s.text = lockedData.text; // Preserve edited text
                  s.values = lockedData.values;
                  if (s.tabs && lockedData.tabValues) {
                    s.tabValues = lockedData.tabValues;
                    if (typeof lockedData.activeTabIndex === 'number') {
                      s.activeTabIndex = lockedData.activeTabIndex;
                    }
                  }
                }
              });
            });
          }

          console.log("Working state loaded from localStorage with locked sentences preserved.");
        } catch (e) {
          console.error("Failed to parse saved state, using defaults from loaded config.", e);
          localStorage.removeItem(LOCAL_STORAGE_KEY);
          resetToCurrentConfigDefaults(false); // Don't rebuild UI yet
        }
      } else {
        console.log("No saved working state found, using defaults from loaded config.");
        resetToCurrentConfigDefaults(false); // Don't rebuild UI yet
      }
      sentenceIdCounter = findHighestSentenceId(narrativeSections) + 1;
    }

    function saveState() {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(narrativeSections));
      } catch (e) {
        console.error("Failed to save state.", e);
        showConfirmationModal("Save Error", "Could not save changes to browser storage. Storage might be full.", "", () => { }, () => { }, true);
      }
    }

    // --- resetToCurrentConfigDefaults remains the same but will now re-apply locks correctly ---
    function resetToCurrentConfigDefaults(rebuildUI = true) {
      // Store locked sentences with their values before reset
      const lockedSentenceData = new Map();
      narrativeSections.forEach(sec =>
        sec.sentences?.forEach(s => {
          if (s.locked) {
            // Store complete sentence data including text and all values
            lockedSentenceData.set(s.id, {
              text: s.text, // Store the text content specifically
              values: s.values ? { ...s.values } : {}, // Copy values
              tabValues: s.tabValues ? JSON.parse(JSON.stringify(s.tabValues)) : [], // Deep copy tab values if present
              activeTabIndex: s.activeTabIndex // Remember active tab
            });
          }
        })
      );

      console.log(`Resetting to defaults for config: ${currentConfigName}`);
      narrativeSections = JSON.parse(JSON.stringify(defaultNarrativeSections));
      assignInitialIDs(narrativeSections); // IDs preserved from defaultNarrativeSections, so lockedIDs now match

      // Re-apply locks and restore their values
      narrativeSections.forEach(sec =>
        sec.sentences?.forEach(s => {
          if (lockedSentenceData.has(s.id)) {
            const savedData = lockedSentenceData.get(s.id);
            s.locked = true;

            // Restore text and values
            if (savedData.text) {
              s.text = savedData.text;
            }

            // For non-tabbed sentences
            if (savedData.values && Object.keys(savedData.values).length > 0) {
              s.values = savedData.values;
            }

            // For tabbed sentences
            if (s.tabs && savedData.tabValues && savedData.tabValues.length > 0) {
              s.tabValues = savedData.tabValues;
              // Only restore activeTabIndex if it's valid for this sentence
              if (typeof savedData.activeTabIndex === 'number' &&
                savedData.activeTabIndex >= 0 &&
                savedData.activeTabIndex < s.tabs.length) {
                s.activeTabIndex = savedData.activeTabIndex;
              }
            }
          }
        })
      );

      saveState(); // Save this state so it persists across refreshes

      if (rebuildUI) {
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }

      // Clear the final text area and warnings
      document.getElementById("finalText").value = "";

      // Clear the placeholder warning without checking
      showPlaceholderWarning(false);

      // Clear the locked sentences info
      const copyLockedInfoEl = document.getElementById('copyLockedInfo');
      if (copyLockedInfoEl) {
        copyLockedInfoEl.style.display = 'none';
      }
    }

    // --- ID and Value Initialization ---
    function assignInitialIDs(sections) {
      let maxId = 0;
      sections.forEach(section => {
        if (!section.sentences) section.sentences = [];
        section.sentences.forEach(sentenceObj => {
          if (!sentenceObj.id || !sentenceObj.id.startsWith('sentence-')) {
            sentenceObj.id = "sentence-" + sentenceIdCounter++;
          } else {
            const idNum = parseInt(sentenceObj.id.split('-')[1]);
            if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
          }
          initializeSentenceValues(sentenceObj); // Ensure values/tabs are initialized
        });
      });
      sentenceIdCounter = Math.max(sentenceIdCounter, maxId + 1);
    }

    // Add dark mode initialization function
    function initializeDarkMode() {
      console.log("Initializing dark mode...");
      const darkModeToggle = document.getElementById('darkModeToggle');

      if (!darkModeToggle) {
        console.error("Dark mode toggle button not found!");
        return;
      }

      // Check localStorage for user preference
      const isDarkMode = localStorage.getItem('darkMode') === 'true';

      // Apply initial theme based on user preference
      if (isDarkMode) {
        document.documentElement.setAttribute('data-bs-theme', 'dark');
        darkModeToggle.innerHTML = '<i class="bi bi-sun-fill"></i>';
      } else {
        document.documentElement.setAttribute('data-bs-theme', 'light');
        darkModeToggle.innerHTML = '<i class="bi bi-moon-fill"></i>';
      }

      // Add event listener for toggle button
      darkModeToggle.addEventListener('click', () => {
        const currentTheme = document.documentElement.getAttribute('data-bs-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

        // Update theme attribute
        document.documentElement.setAttribute('data-bs-theme', newTheme);

        // Update button icon
        darkModeToggle.innerHTML = newTheme === 'dark'
          ? '<i class="bi bi-sun-fill"></i>'
          : '<i class="bi bi-moon-fill"></i>';

        // Save preference to localStorage
        localStorage.setItem('darkMode', newTheme === 'dark');

        console.log(`Theme switched to: ${newTheme}`);
      });

      console.log("Dark mode initialization complete");
    }

    function findHighestSentenceId(sections) {
      let maxId = 0;
      sections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.id && sentenceObj.id.startsWith('sentence-')) {
            const idNum = parseInt(sentenceObj.id.split('-')[1]);
            if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
          }
        });
      });
      return maxId;
    }

    function initializeSentenceValues(sentenceObj) {
      // Initialize for tabbed sentences
      if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
        if (typeof sentenceObj.activeTabIndex === "undefined" || sentenceObj.activeTabIndex >= sentenceObj.tabs.length) {
          sentenceObj.activeTabIndex = 0;
        }
        if (!sentenceObj.tabValues || !Array.isArray(sentenceObj.tabValues) || sentenceObj.tabValues.length !== sentenceObj.tabs.length) {
          sentenceObj.tabValues = sentenceObj.tabs.map(() => ({}));
        } else {
          // Ensure each tab's value store is an object
          sentenceObj.tabValues = sentenceObj.tabValues.map(valStore =>
            (typeof valStore === 'object' && !Array.isArray(valStore) && valStore !== null) ? valStore : {}
          );
        }
      } else { // Initialize for non-tabbed sentences
        if (!sentenceObj.values || Array.isArray(sentenceObj.values)) { // Ensure .values is an object
          sentenceObj.values = {};
        }
      }
    }

    // --- String Manipulation Helpers ---
    function shortPlaceholderString(sentence) {
      return sentence.replace(placeholderRegex, (match, type, label) => `[${label}]`);
    }
    function expandedPlaceholderString(sentence) {
      return sentence.replace(placeholderRegex, (match, theType, label, opts) => opts ? `[${label}(${opts})]` : `[${label}]`);
    }

    // --- UI Building Functions ---
    function buildSectionsUI() {
      const container = document.getElementById("sectionContainer");
      if (!container) { console.error("Section container not found!"); return; }
      container.innerHTML = ""; // Clear existing content
      narrativeSections.forEach(secObj => {
        container.appendChild(createSectionElement(secObj));
      });
      makeSentencesDraggable(); // Make new sentences draggable
      initializeTooltips(); // Re-initialize tooltips for new elements
      // Event listeners (for inputs, dropdowns etc.) are attached via attachAllEventListeners() after full build
      // or attachAllEventListenersForElement() when adding single items.
    }

    function createSectionElement(secObj) {
      const sectionDiv = document.createElement("div");
      sectionDiv.classList.add("narrative-section");
      sectionDiv.dataset.part = secObj.part;

      const header = document.createElement("div");
      header.classList.add("section-header");

      const titleWrapper = document.createElement("span");
      titleWrapper.classList.add("section-title-wrapper");

      const titleEl = document.createElement("h5");
      titleEl.classList.add("section-title", "m-0", "d-inline");

      const mainPartSpan = document.createElement("span");
      mainPartSpan.classList.add("section-title-main");
      mainPartSpan.innerText = secObj.part;
      titleEl.appendChild(mainPartSpan);

      if (secObj.subpart) {
        const subPartSpan = document.createElement("span");
        subPartSpan.classList.add("section-subpart");
        subPartSpan.innerText = secObj.subpart;
        titleEl.appendChild(subPartSpan); // This line was missing - append the subPartSpan to titleEl
      }
      titleWrapper.appendChild(titleEl);

      if (secObj.tooltip) {
        titleWrapper.setAttribute('data-bs-toggle', 'tooltip');
        titleWrapper.setAttribute('data-bs-placement', 'top');
        titleWrapper.setAttribute('title', secObj.tooltip);
      }
      header.appendChild(titleWrapper);
      sectionDiv.appendChild(header);

      const ul = document.createElement("ul");
      ul.classList.add("sentence-list");
      ul.dataset.part = secObj.part; // For SortableJS group identification
      if (secObj.sentences) {
        secObj.sentences.forEach(sentenceObj => {
          ul.appendChild(createSentenceElement(sentenceObj, secObj.part));
        });
      }
      sectionDiv.appendChild(ul);
      sectionDiv.appendChild(createAddSentenceForm(secObj)); // Add form for adding new sentences
      return sectionDiv;
    }

    function createSentenceElement(sentenceObj, partLabel) {
      initializeSentenceValues(sentenceObj); // Ensure values are ready
      const li = document.createElement("li");
      li.dataset.id = sentenceObj.id;
      li.dataset.part = partLabel; // Keep track of which part it belongs to

      // Drag Handle
      const handle = document.createElement("span");
      handle.classList.add("drag-handle");
      handle.innerHTML = "&#9776;"; // Hamburger icon for dragging
      handle.title = "Drag to reorder or move to another section";
      li.appendChild(handle);

      // Content Area (for text and inline fields)
      const contentDiv = document.createElement('div');
      contentDiv.classList.add('sentence-content');

      if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
        li.classList.add("has-tabs");
        li.appendChild(createTabsContainer(sentenceObj)); // Tabs go above contentDiv
        sentenceObj.tabs.forEach((tab, i) => {
          contentDiv.appendChild(createTabPaneElement(sentenceObj, i));
        });
      } else {
        contentDiv.innerHTML = buildInlineFields(sentenceObj.text, sentenceObj.values);
      }
      li.appendChild(contentDiv);

      // Controls (Edit, Lock, Remove buttons)
      const controls = document.createElement('div');
      controls.classList.add('sentence-controls');
      controls.append(
        createEditButton(sentenceObj, partLabel),
        createLockButton(sentenceObj, partLabel),
        createRemoveButton(sentenceObj.id, partLabel)
      );
      li.appendChild(controls);
      return li;
    }

    function createTabsContainer(sentenceObj) {
      const tabsContainer = document.createElement("div");
      tabsContainer.classList.add("tabs-container");
      sentenceObj.tabs.forEach((tab, i) => {
        const tabBtn = document.createElement("button");
        tabBtn.classList.add("tab-button");
        tabBtn.type = "button"; // Important for forms
        if (i === sentenceObj.activeTabIndex) tabBtn.classList.add("active");
        tabBtn.innerText = tab.title || `Tab ${i + 1}`;
        tabBtn.dataset.tabIndex = i;
        tabBtn.addEventListener("click", () => switchTab(sentenceObj.id, i));
        tabsContainer.appendChild(tabBtn);
      });
      return tabsContainer;
    }

    function createTabPaneElement(sentenceObj, tabIndex) {
      const tabPane = document.createElement("div");
      tabPane.classList.add("tab-pane");
      tabPane.dataset.tabIndex = tabIndex;
      if (tabIndex === sentenceObj.activeTabIndex) tabPane.classList.add("active");

      const tabContent = sentenceObj.tabs[tabIndex].text || "";
      const tabValues = sentenceObj.tabValues[tabIndex] || {}; // Ensure tabValues for this index exists
      tabPane.innerHTML = buildInlineFields(tabContent, tabValues);
      return tabPane;
    }

    function createRemoveButton(sentenceId, partLabel) {
      const removeBtn = document.createElement("button");
      removeBtn.classList.add("btn", "btn-sm", "remove-sentence-btn"); // Bootstrap and custom classes
      removeBtn.type = "button";
      removeBtn.innerHTML = "&times;"; // "X" symbol for remove
      removeBtn.title = "Remove Sentence";
      removeBtn.setAttribute('aria-label', 'Remove sentence');
      removeBtn.addEventListener("click", (e) => {
        e.stopPropagation(); // Prevent event bubbling
        showConfirmationModal("Remove Sentence", "Are you sure you want to remove this sentence?", "",
          () => removeSentence(partLabel, sentenceId),
          () => { } // No action on "No"
        );
      });
      return removeBtn;
    }

    function createEditButton(sentenceObj, partLabel) {
      const btn = document.createElement('button');
      btn.classList.add('btn', 'btn-sm', 'edit-sentence-btn');
      btn.title = 'Edit Sentence Text';
      btn.innerHTML = '<i class="bi bi-pencil-fill"></i>';
      btn.setAttribute('aria-label', 'Edit sentence text');
      btn.addEventListener('click', () => {
        // Get the content div that contains the sentence text
        const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
        const contentDiv = li.querySelector('.sentence-content');

        // Check if already in edit mode
        if (contentDiv.classList.contains('editing')) {
          console.log('Sentence is already in edit mode');
          return;
        }

        let currentText, activeTabIndex, isTabbed;

        // Determine if this is a tabbed sentence and get the appropriate text
        if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
          isTabbed = true;
          activeTabIndex = sentenceObj.activeTabIndex || 0;
          currentText = sentenceObj.tabs[activeTabIndex].text || "";
        } else {
          isTabbed = false;
          currentText = sentenceObj.text || "";
        }

        const originalHTML = contentDiv.innerHTML;

        // Mark as being edited
        contentDiv.classList.add('editing');

        // Create an editable textarea
        const textarea = document.createElement('textarea');
        textarea.classList.add('form-control', 'sentence-edit-textarea', 'auto-height-textarea');
        textarea.value = currentText;

        // Replace content with textarea
        contentDiv.innerHTML = '';
        contentDiv.appendChild(textarea);

        // Add save and cancel buttons
        const buttonsDiv = document.createElement('div');
        buttonsDiv.classList.add('edit-buttons', 'mt-2');

        const saveBtn = document.createElement('button');
        saveBtn.classList.add('btn', 'btn-sm', 'btn-primary', 'me-2');
        saveBtn.innerHTML = 'Save';

        const cancelBtn = document.createElement('button');
        cancelBtn.classList.add('btn', 'btn-sm', 'btn-secondary');
        cancelBtn.innerHTML = 'Cancel';

        buttonsDiv.appendChild(saveBtn);
        buttonsDiv.appendChild(cancelBtn);
        contentDiv.appendChild(buttonsDiv);

        // Auto-adjust textarea height
        adjustTextareaHeight(textarea);
        textarea.focus();

        // Save changes
        saveBtn.addEventListener('click', () => {
          const newText = textarea.value.trim();
          if (newText !== currentText) {
            if (isTabbed) {
              // Update the specific tab's text
              sentenceObj.tabs[activeTabIndex].text = newText;
              // Rebuild the content to show updated tabs
              contentDiv.innerHTML = '';
              if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
                sentenceObj.tabs.forEach((tab, i) => {
                  contentDiv.appendChild(createTabPaneElement(sentenceObj, i));
                });
              }
            } else {
              // Update regular sentence text
              sentenceObj.text = newText;
              contentDiv.innerHTML = buildInlineFields(newText, sentenceObj.values || {});
            }

            attachAllEventListenersForElement(contentDiv);
            adjustAllInitialSizesForElement(contentDiv);
            saveState();
          } else {
            contentDiv.innerHTML = originalHTML;
          }
          // Remove editing class
          contentDiv.classList.remove('editing');
        });

        // Cancel editing
        cancelBtn.addEventListener('click', () => {
          contentDiv.innerHTML = originalHTML;
          contentDiv.classList.remove('editing');
        });
      });
      return btn;
    }

    function createLockButton(sentenceObj, partLabel) {
      const btn = document.createElement('button');
      btn.classList.add('btn', 'btn-sm', 'lock-sentence-btn');
      btn.title = sentenceObj.locked ? 'Unlock Sentence' : 'Lock Sentence (prevents deletion in New Run)';
      btn.setAttribute('aria-label', sentenceObj.locked ? 'Unlock sentence' : 'Lock sentence');
      btn.innerHTML = `<i class="bi bi-lock${sentenceObj.locked ? '-fill text-primary' : ''}"></i>`;

      btn.addEventListener('click', () => {
        sentenceObj.locked = !sentenceObj.locked;
        // Update button appearance immediately
        btn.title = sentenceObj.locked ? 'Unlock Sentence' : 'Lock Sentence';
        btn.setAttribute('aria-label', sentenceObj.locked ? 'Unlock sentence' : 'Lock sentence');
        btn.innerHTML = `<i class="bi bi-lock${sentenceObj.locked ? '-fill text-primary' : ''}"></i>`;
        saveState(); // Save state when lock status changes
        // No need to rebuild UI just for lock state change if only icon/title changes
      });
      return btn;
    }


    function createAddSentenceForm(secObj) {
      const form = document.createElement("form");
      form.classList.add("add-item-form");
      form.dataset.part = secObj.part;
      form.addEventListener('submit', (e) => e.preventDefault()); // Prevent default form submission

      const groupDiv = document.createElement("div");
      groupDiv.classList.add("add-item-group");

      const textarea = document.createElement("textarea");
      textarea.classList.add("form-control", "form-control-sm", "auto-height-textarea");
      textarea.placeholder = "Type to add new sentence or search existing...";
      textarea.setAttribute('aria-label', `Add sentence to ${secObj.part}`);
      textarea.rows = 1; // Start with a single row

      const addBtn = document.createElement("button");
      addBtn.type = "button"; // Important: type="button" to prevent form submission
      addBtn.classList.add("btn", "btn-sm", "btn-secondary");
      addBtn.innerText = "Add";
      addBtn.title = "Add new sentence from text area";

      // Add the missing click event listener for the Add button
      addBtn.addEventListener("click", () => {
        const newText = textarea.value.trim();
        if (newText) {
          addSentence(secObj.part, { text: newText });
          textarea.value = "";
          adjustTextareaHeight(textarea);
          suggestionsBox.style.display = 'none';
        }
      });

      // Add sentence on Enter (but not Shift+Enter for new lines)
      textarea.addEventListener("keypress", (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault(); // Prevent new line
          const newText = textarea.value.trim();
          if (newText) {
            addSentence(secObj.part, { text: newText });
            textarea.value = "";
            adjustTextareaHeight(textarea);
            suggestionsBox.style.display = 'none';
          }
        }
      });

      groupDiv.appendChild(textarea);
      groupDiv.appendChild(addBtn);

      // Suggestions Box for autocomplete
      const suggestionsBox = document.createElement("div");
      suggestionsBox.classList.add("suggestions-box");
      const suggestionsUl = document.createElement("ul");
      suggestionsBox.appendChild(suggestionsUl);

      form.appendChild(groupDiv);
      form.appendChild(suggestionsBox);

      // Event listeners for textarea (autocomplete and auto-height)
      textarea.addEventListener("input", () => {
        handleSuggestionsInput(textarea, suggestionsBox, secObj.part);
        adjustTextareaHeight(textarea);
      });
      textarea.addEventListener("blur", () => {
        // Delay hiding suggestions to allow click on a suggestion
        setTimeout(() => { suggestionsBox.style.display = "none"; }, 150);
      });
      return form;
    }

    // --- UI Interaction Functions ---
    function handleSuggestionsInput(inputElement, suggestionsBoxElement, partLabel) {
      const query = inputElement.value.trim();
      const ulEl = suggestionsBoxElement.querySelector("ul");
      if (!ulEl) return;
      ulEl.innerHTML = ""; // Clear previous suggestions

      if (query.length < fuseOptions.minMatchCharLength) {
        suggestionsBoxElement.style.display = "none";
        return;
      }

      const fuseResults = fuse.search(query);
      if (fuseResults.length === 0) {
        suggestionsBoxElement.style.display = "none";
        return;
      }

      fuseResults.slice(0, 10).forEach((res) => { // Show top 10 results
        const li = document.createElement("li");
        li.textContent = res.item.display; // Show shortened version
        li.title = res.item.original;    // Full text on hover

        // Use mousedown for selection to fire before blur on textarea
        li.addEventListener("mousedown", () => {
          addSentence(partLabel, { text: res.item.original });
          inputElement.value = ""; // Clear input
          if (inputElement.tagName === 'TEXTAREA') adjustTextareaHeight(inputElement);
          suggestionsBoxElement.style.display = "none";
        });
        ulEl.appendChild(li);
      });
      suggestionsBoxElement.style.display = "block";
    }

    function addSentence(partLabel, sentenceData) {
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section) { console.error(`Section ${partLabel} not found.`); return; }

      sentenceData.id = "sentence-" + sentenceIdCounter++;
      initializeSentenceValues(sentenceData); // Ensure values are initialized
      if (!section.sentences) section.sentences = [];
      section.sentences.push(sentenceData);
      console.log(`Sentence added: ${sentenceData.id} to ${partLabel}`);

      const ul = document.querySelector(`.sentence-list[data-part="${partLabel}"]`);
      if (ul) {
        const li = createSentenceElement(sentenceData, partLabel);
        ul.appendChild(li);
        // Attach listeners and adjust sizes for the new element specifically
        attachAllEventListenersForElement(li);
        adjustAllInitialSizesForElement(li);
        li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } else {
        // Fallback: if UL not found (should not happen if structure is correct), rebuild
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }
      saveState();
    }

    function removeSentence(partLabel, sentenceId) {
      const section = narrativeSections.find(s => s.part === partLabel);
      if (!section || !section.sentences) return;

      const index = section.sentences.findIndex(s => s.id === sentenceId);
      if (index > -1) {
        section.sentences.splice(index, 1);
        console.log(`Sentence data removed: ${sentenceId}`);
        const li = document.querySelector(`li[data-id="${sentenceId}"]`);
        if (li) {
          li.remove();
          console.log(`Sentence DOM element removed: ${sentenceId}`);
        } else { // Fallback if DOM element somehow not found
          buildSectionsUI();
          attachAllEventListeners();
          adjustAllInitialSizes();
        }
        saveState();
      } else {
        console.warn(`Sentence ID ${sentenceId} not found in section ${partLabel} data.`);
      }
    }

    function switchTab(sentenceId, tabIndex) {
      const sentenceObj = findSentenceById(sentenceId);
      if (!sentenceObj || !sentenceObj.tabs) return;
      if (tabIndex < 0 || tabIndex >= sentenceObj.tabs.length) return;

      const li = document.querySelector(`li[data-id="${sentenceId}"]`);
      if (!li) return;

      // Check if currently in edit mode - prevent tab switching
      const contentDiv = li.querySelector('.sentence-content');
      if (contentDiv && contentDiv.classList.contains('editing')) {
        console.log('Cannot switch tabs while editing. Please save or cancel your changes first.');
        showConfirmationModal(
          "Edit in Progress",
          "Please save or cancel your current changes before switching tabs.",
          "",
          () => { },
          () => { },
          true
        );
        return;
      }

      sentenceObj.activeTabIndex = tabIndex;
      console.log(`Switched to tab ${tabIndex} for sentence ${sentenceId}`);

      if (li) {
        // Update tab button active states
        const tabButtons = li.querySelectorAll('.tabs-container .tab-button');
        tabButtons.forEach((btn, index) => btn.classList.toggle('active', index === tabIndex));

        // Update tab pane active states and content
        const tabPanes = li.querySelectorAll('.sentence-content .tab-pane');
        tabPanes.forEach((pane, index) => {
          const isActive = index === tabIndex;
          pane.classList.toggle('active', isActive);
          if (isActive) {
            // Rebuild content for the newly active tab
            const tabContent = sentenceObj.tabs[index].text || "";
            const tabValues = sentenceObj.tabValues[index] || {};
            pane.innerHTML = buildInlineFields(tabContent, tabValues);
            // Re-attach listeners and adjust sizes for the new content in the active tab
            attachAllEventListenersForElement(pane);
            adjustAllInitialSizesForElement(pane);
          }
        });
      } else { // Fallback if sentence <li> not found
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
      }
      saveState();
    }


    // --- Input Value Handling (Saving on Blur) ---
    function attachBlurListeners() {
      const container = document.getElementById('sectionContainer');
      if (!container) return;
      // Use event delegation for blur on inline fields
      container.removeEventListener('blur', handleInlineFieldBlurDelegated, true); // Remove previous if any
      container.addEventListener('blur', handleInlineFieldBlurDelegated, true); // Capture phase
    }
    function attachBlurListenersForElement(element) {
      // For dynamically added elements, attach directly if delegation isn't covering it
      element.querySelectorAll('.inline-field[data-label]').forEach(field => {
        field.removeEventListener('blur', handleInlineFieldBlur); // Prevent duplicates
        field.addEventListener('blur', handleInlineFieldBlur);
      });
    }

    function handleInlineFieldBlurDelegated(event) {
      if (event.target.matches('.inline-field[data-label]')) {
        handleInlineFieldBlur(event);
      }
    }
    function handleInlineFieldBlur(event) {
      const field = event.target;
      const label = field.dataset.label;
      const value = field.value;
      const li = field.closest('li[data-id]');
      if (!li || !label) return;

      const sentenceId = li.dataset.id;
      const sentenceObj = findSentenceById(sentenceId);
      if (!sentenceObj) return;

      const tabPane = field.closest('.tab-pane[data-tab-index]');
      let valueChanged = false;

      if (tabPane) { // Value is within a tab
        const tabIndex = parseInt(tabPane.dataset.tabIndex);
        if (!isNaN(tabIndex) && sentenceObj.tabValues?.[tabIndex]) {
          if (sentenceObj.tabValues[tabIndex][label] !== value) {
            sentenceObj.tabValues[tabIndex][label] = value;
            valueChanged = true;
          }
        }
      } else if (sentenceObj.values) { // Value is in a non-tabbed sentence
        if (sentenceObj.values[label] !== value) {
          sentenceObj.values[label] = value;
          valueChanged = true;
        }
      }
      
      // Remove empty field highlighting when value is entered
      if (value && value.trim() !== '') {
        field.classList.remove('empty-field');
      }
      
      if (valueChanged) {
        console.log(`Value saved for ${sentenceId} - ${label}: ${value}`);
        saveState();
        
        // Remove placeholder check on blur - only check when generating text
      }
    }

    /** Stores all inline field values into the JS data structure. Called before generation. */
    function storeAllInlineValues() {
      let changesMade = false;
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
          if (!li) return; // Skip if DOM element not found

          initializeSentenceValues(sentenceObj); // Ensure value objects exist

          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            sentenceObj.tabs.forEach((tab, tabIndex) => {
              const tabPane = li.querySelector(`.tab-pane[data-tab-index="${tabIndex}"]`);
              if (!tabPane) return;
              if (!sentenceObj.tabValues[tabIndex]) sentenceObj.tabValues[tabIndex] = {}; // Should be initialized already

              tabPane.querySelectorAll(".inline-field[data-label]").forEach(field => {
                const label = field.dataset.label;
                const newValue = field.value;
                if (sentenceObj.tabValues[tabIndex][label] !== newValue) {
                  sentenceObj.tabValues[tabIndex][label] = newValue;
                  changesMade = true;
                }
              });
            });
          } else { // Non-tabbed sentence
            if (!sentenceObj.values) sentenceObj.values = {}; // Should be initialized already

            li.querySelectorAll(".sentence-content > .inline-field[data-label]").forEach(field => {
              // Ensure we only get direct children of sentence-content, not those inside tab-panes if any mix-up
              const label = field.dataset.label;
              const newValue = field.value;
              if (sentenceObj.values[label] !== newValue) {
                sentenceObj.values[label] = newValue;
                changesMade = true;
              }
            });
          }
        });
      });
      if (changesMade) console.log("Stored all inline values, changes detected.");
      return changesMade;
    }


    // --- HTML Building for Inline Fields ---
    function buildInlineFields(textTemplate, valuesObject) {
      if (!valuesObject) valuesObject = {}; // Ensure valuesObject is an object
      const cleanText = (textTemplate || "").replace(/<br\s*\/?>/gi, ""); // Remove <br> tags

      // If there are no placeholders in the text, return the clean text as-is
      if (!placeholderRegex.test(cleanText)) {
        return cleanText;
      }

      return cleanText.replace(placeholderRegex, (match, type, label, options) => {
        const currentValue = valuesObject[label] || "";
        let dropdownOptionsArray = [];

        if (options) { // Options defined directly in template
          dropdownOptionsArray = options.split(",").map(x => x.trim());
        } else if (globalDropdownOptions[label]) { // Options from global config
          dropdownOptionsArray = globalDropdownOptions[label];
        }
        // else: it's a text or number field, or a dropdown with no predefined options (less common)

        switch (type) {
          case "customDropdown":
            const listItems = dropdownOptionsArray.map(opt => {
              const isHidden = opt.startsWith(HIDDEN_ITEM_MARKER);
              const displayOpt = isHidden ? opt.substring(HIDDEN_ITEM_MARKER.length) : opt;
              const hiddenAttr = isHidden ? ' data-hidden="true"' : '';
              return `<li class="list-group-item"${hiddenAttr} title="${displayOpt}">${displayOpt}</li>`;
            }).join("");
            return `
            <div class="custom-dropdown">
              <input type="text" class="inline-field custom-dropdown-input" data-type="customDropdown" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocomplete="off"/>
              <div class="suggestions">
                <ul class="list-group">${listItems}</ul>
              </div>
            </div>`;
          case "text":
            return `<input type="text" class="inline-field" data-type="text" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}"/>`;
          case "number":
            return `<input type="number" class="inline-field" data-type="number" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}"/>`;
          case "dropdown": // This type might be legacy or needs specific handling if different from customDropdown
            console.warn(`Standard 'dropdown' type encountered for [${label}]. Consider using 'customDropdown' for richer features or ensure specific handling is implemented if needed.`);
            // Basic input for now, can be enhanced if standard dropdowns have unique behavior
            return `<input type="text" class="inline-field" data-type="dropdown" data-label="${label}" placeholder="${label}" value="${currentValue}" title="${currentValue || label}" autocomplete="off"/>`;
          default:
            console.warn(`Unknown placeholder type: ${type} for label: ${label}`);
            return match; // Return original match if type is unknown
        }
      });
    }

    // --- Drag and Drop ---
    function makeSentencesDraggable() {
      const lists = document.querySelectorAll(".sentence-list");
      lists.forEach(ul => {
        // Destroy existing Sortable instance if present, to avoid duplicates
        const existingSortable = Sortable.get(ul);
        if (existingSortable) {
          existingSortable.destroy();
        }
        new Sortable(ul, {
          animation: 150,
          group: { name: "narrativeGroup", pull: true, put: true }, // Allow dragging between lists
          handle: ".drag-handle", // Specify drag handle
          ghostClass: "sortable-ghost",  // Class for the drop placeholder
          chosenClass: "sortable-chosen", // Class for the chosen item
          dragClass: "sortable-drag",    // Class for the dragging item
          onEnd: handleDragEnd,
        });
      });
    }

    function handleDragEnd(evt) {
      const itemEl = evt.item; // The dragged element
      const sentenceId = itemEl.dataset.id;
      const toListEl = evt.to;   // List element where item was dropped
      const fromListEl = evt.from; // List element from where item was dragged
      const oldIndex = evt.oldDraggableIndex; // Original index in old list
      const newIndex = evt.newDraggableIndex; // New index in new list

      const toPartLabel = toListEl.dataset.part;
      const fromPartLabel = fromListEl.dataset.part;

      console.log(`Sentence ${sentenceId} moved from ${fromPartLabel}[${oldIndex}] to ${toPartLabel}[${newIndex}]`);

      // Find the sentence object in our JavaScript data
      const fromSection = narrativeSections.find(s => s.part === fromPartLabel);
      if (!fromSection || !fromSection.sentences) { console.error("Source section data not found."); return; }

      // Remove sentence from old location in data
      const [movedSentence] = fromSection.sentences.splice(oldIndex, 1);
      if (!movedSentence || movedSentence.id !== sentenceId) {
        console.error("Sentence data mismatch during drag operation. Rebuilding UI to prevent data corruption.");
        // Critical error, rebuild UI from current (potentially slightly off) state to be safe
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
        return;
      }

      // Add sentence to new location in data
      const toSection = narrativeSections.find(s => s.part === toPartLabel);
      if (!toSection) {
        console.error("Target section data not found. Reverting move.");
        fromSection.sentences.splice(oldIndex, 0, movedSentence); // Put it back
        // Rebuild UI as a fallback
        buildSectionsUI();
        attachAllEventListeners();
        adjustAllInitialSizes();
        return;
      }
      if (!toSection.sentences) toSection.sentences = [];
      toSection.sentences.splice(newIndex, 0, movedSentence);

      // Update the dataset.part on the DOM element if it moved to a new section
      if (fromPartLabel !== toPartLabel) {
        itemEl.dataset.part = toPartLabel;
      }

      saveState(); // Save the new order/location
      // No need to rebuild UI if SortableJS handles DOM update, unless cross-list styling changes.
    }

    // --- Custom Dropdown Logic ---
    function attachDropdownLogic() {
      const container = document.getElementById('sectionContainer');
      if (!container) return;

      // Focus: Show/filter suggestions
      container.removeEventListener('focusin', handleDropdownFocusDelegated); // Use focusin for better delegation
      container.addEventListener('focusin', handleDropdownFocusDelegated);

      // Input: Filter suggestions dynamically
      container.removeEventListener('input', handleDropdownInputDelegated);
      container.addEventListener('input', handleDropdownInputDelegated);

      // Keydown: Navigate suggestions, select, escape
      container.removeEventListener('keydown', handleDropdownKeydownDelegated);
      container.addEventListener('keydown', handleDropdownKeydownDelegated);

      // Mousedown on suggestion: Select item (use mousedown to fire before blur)
      container.removeEventListener('mousedown', handleDropdownSuggestionClickDelegated);
      container.addEventListener('mousedown', handleDropdownSuggestionClickDelegated);

      // Blur: Hide suggestions (with delay)
      container.removeEventListener('focusout', handleDropdownBlurDelegated); // Use focusout
      container.addEventListener('focusout', handleDropdownBlurDelegated);
    }

    function attachDropdownLogicForElement(element) {
      const dropdownInputs = element.matches('.custom-dropdown-input') ? [element] : element.querySelectorAll(".custom-dropdown-input");
      dropdownInputs.forEach(input => {
        const dropdownContainer = input.closest('.custom-dropdown');
        if (!dropdownContainer) return;
        const suggestionBox = dropdownContainer.querySelector(".suggestions");
        if (!suggestionBox) return;

        input.removeEventListener('focus', handleDropdownFocusDirect); input.addEventListener('focus', handleDropdownFocusDirect);
        input.removeEventListener('input', handleDropdownInputDirect); input.addEventListener('input', handleDropdownInputDirect);
        input.removeEventListener('keydown', handleDropdownKeydownDirect); input.addEventListener('keydown', handleDropdownKeydownDirect);
        // Click/mousedown on suggestions is handled by delegation on suggestionBox or its parent
        suggestionBox.removeEventListener('mousedown', handleDropdownSuggestionClickDirect); // Attach to suggestionBox
        suggestionBox.addEventListener('mousedown', handleDropdownSuggestionClickDirect);
        input.removeEventListener('blur', handleDropdownBlurDirect); input.addEventListener('blur', handleDropdownBlurDirect);
      });
    }

    // Delegated handlers
    function handleDropdownFocusDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownInputDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownKeydownDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) processDropdownKeydown(event.target, event);
    }
    function handleDropdownSuggestionClickDelegated(event) {
      if (event.target.matches('.custom-dropdown .suggestions li')) {
        const input = event.target.closest('.custom-dropdown')?.querySelector('.custom-dropdown-input');
        if (input) {
          selectDropdownItem(input, event.target);
          hideDropdownSuggestions(input); // Hide after selection
          // Manually trigger blur's save logic for the input field
          handleInlineFieldBlur({ target: input });
        }
      }
    }
    function handleDropdownBlurDelegated(event) {
      if (event.target.matches('.custom-dropdown-input')) {
        // Check if the relatedTarget (where focus went) is part of the suggestions
        const dropdownContainer = event.target.closest('.custom-dropdown');
        const suggestionBox = dropdownContainer?.querySelector('.suggestions');
        if (suggestionBox && suggestionBox.contains(event.relatedTarget)) {
          return; // Don't hide if focus moved to a suggestion
        }
        processDropdownBlur(event.target);
      }
    }

    // Direct handlers (for dynamically added elements if delegation is tricky)
    function handleDropdownFocusDirect(event) {
      filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownInputDirect(event) {
      filterAndShowDropdownSuggestions(event.target);
    }
    function handleDropdownKeydownDirect(event) {
      processDropdownKeydown(event.target, event);
    }
    function handleDropdownSuggestionClickDirect(event) { // Attached to suggestionBox
      if (event.target.matches('li')) { // Check if a list item was clicked
        const input = event.currentTarget.closest('.custom-dropdown')?.querySelector('.custom-dropdown-input');
        if (input) {
          selectDropdownItem(input, event.target);
          hideDropdownSuggestions(input);
          handleInlineFieldBlur({ target: input });
        }
      }
    }
    function handleDropdownBlurDirect(event) {
      const dropdownContainer = event.target.closest('.custom-dropdown');
      const suggestionBox = dropdownContainer?.querySelector('.suggestions');
      if (suggestionBox && suggestionBox.contains(document.activeElement) && document.activeElement !== event.target) {
        // If focus is now on a suggestion item, don't hide yet.
        // The click on the suggestion will handle hiding.
        return;
      }
      processDropdownBlur(event.target);
    }

    /** Filters suggestions based on input, handles hidden items, positions and shows dropdown. (NEW/REVISED) */
    function filterAndShowDropdownSuggestions(inputElement) {
      const dropdownContainer = inputElement.closest('.custom-dropdown');
      const suggestionBox = dropdownContainer?.querySelector(".suggestions");
      const liAncestor = inputElement.closest('li'); // Position relative to the LI
      if (!suggestionBox || !liAncestor) {
        console.error("Cannot find suggestions box or list item for input:", inputElement);
        return;
      }

      const filterText = inputElement.value.toLowerCase().trim();
      const items = Array.from(suggestionBox.querySelectorAll("li"));
      let hasVisibleItems = false;

      items.forEach(item => {
        const itemText = item.textContent.toLowerCase();
        const isHiddenByDefault = item.dataset.hidden === 'true';

        // Determine visibility based on filter text
        let shouldShow = true;
        if (filterText) {
          // If filtering, show if text matches (hidden status doesn't matter)
          shouldShow = itemText.includes(filterText);
        } else {
          // If not filtering (just focused), hide items marked as hidden
          shouldShow = !isHiddenByDefault;
        }

        item.style.display = shouldShow ? "" : "none";
        if (shouldShow) {
          hasVisibleItems = true;
        }
      });

      // Only show the box if there are items to display
      if (hasVisibleItems) {
        positionDropdownSuggestions(inputElement, suggestionBox, liAncestor);
        suggestionBox.style.display = "block";
        highlightDropdownItem(items.filter(li => li.style.display !== 'none'), -1); // Reset highlight on filter/show
      } else {
        suggestionBox.style.display = "none";
      }
    }

    function positionDropdownSuggestions(inputElement, suggestionBox, liAncestor) {
      const inputRect = inputElement.getBoundingClientRect();

      // Position relative to the viewport
      suggestionBox.style.position = 'fixed'; // Use fixed positioning for viewport coordinates
      suggestionBox.style.left = `${inputRect.left}px`;
      suggestionBox.style.top = `${inputRect.bottom + 2}px`; // 2px gap below input
      suggestionBox.style.minWidth = `${inputRect.width}px`;
      suggestionBox.style.maxWidth = `350px`; // Max width constraint
      suggestionBox.style.zIndex = '1000'; // Ensure it appears above other content

      // Store reference to the input element on the suggestion box for repositioning during scroll
      suggestionBox.dataset.linkedInputId = inputElement.id || '';

      // If input doesn't have an ID, create one so we can reference it later
      if (!inputElement.id) {
        inputElement.id = 'dropdown-input-' + Math.random().toString(36).substring(2, 10);
        suggestionBox.dataset.linkedInputId = inputElement.id;
      }

      // Add this dropdown to the active dropdowns collection if it's not already tracked
      if (suggestionBox.style.display !== 'none' && !activeDropdowns.includes(suggestionBox)) {
        activeDropdowns.push(suggestionBox);

        // Ensure scroll listener is attached if this is the first visible dropdown
        if (activeDropdowns.length === 1) {
          window.addEventListener('scroll', handleScrollForDropdowns, { passive: true });
        }
      }

      // Use requestAnimationFrame to ensure styles are applied and dimensions are available
      requestAnimationFrame(() => {
        const suggestionsRect = suggestionBox.getBoundingClientRect();

        // Check if dropdown extends beyond viewport bottom
        if (suggestionsRect.bottom > window.innerHeight) {
          const spaceAbove = inputRect.top; // Space above input in viewport

          if (suggestionsRect.height < spaceAbove) {
            // If it fits above the input, position it above
            suggestionBox.style.top = `${inputRect.top - suggestionsRect.height - 2}px`;
          } else {
            // Otherwise, position at bottom with a max-height constraint
            const maxHeight = window.innerHeight - inputRect.bottom - 10; // 10px from bottom of viewport
            suggestionBox.style.maxHeight = `${maxHeight}px`;
            suggestionBox.style.overflowY = 'auto';
          }
        }

        // Check if dropdown extends beyond viewport right edge
        if (suggestionsRect.right > window.innerWidth) {
          suggestionBox.style.left = `${window.innerWidth - suggestionsRect.width - 5}px`; // 5px padding from right edge
        }

        // Check if dropdown extends beyond viewport left edge
        if (suggestionsRect.left < 0) {
          suggestionBox.style.left = '5px'; // 5px padding from left edge
        }
      });
    }

    function processDropdownKeydown(inputElement, event) {
      const suggestionBox = inputElement.closest('.custom-dropdown')?.querySelector(".suggestions");
      if (!suggestionBox || suggestionBox.style.display === 'none') return;

      const visibleItems = Array.from(suggestionBox.querySelectorAll("li:not([style*='display: none'])"));
      if (visibleItems.length === 0 && event.key !== 'Escape') return; // Allow Escape even if no items

      let focusedIndex = visibleItems.findIndex(item => item.classList.contains('highlight'));

      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          focusedIndex = (focusedIndex <= 0) ? visibleItems.length - 1 : focusedIndex - 1;
          highlightDropdownItem(visibleItems, focusedIndex);
          break;
        case 'ArrowDown':
          event.preventDefault();
          focusedIndex = (focusedIndex < 0 || focusedIndex >= visibleItems.length - 1) ? 0 : focusedIndex + 1;
          highlightDropdownItem(visibleItems, focusedIndex);
          break;
        case 'Enter':
        case 'Tab': // Treat Tab like Enter for selection if an item is highlighted
          if (focusedIndex >= 0 && focusedIndex < visibleItems.length) {
            event.preventDefault();
            selectDropdownItem(inputElement, visibleItems[focusedIndex]);
            hideDropdownSuggestions(inputElement);
            handleInlineFieldBlur({ target: inputElement }); // Ensure save
          } else if (event.key === 'Enter') { // If Enter but no selection, just hide
            event.preventDefault();
            hideDropdownSuggestions(inputElement);
            // inputElement.blur(); // Optionally blur
          }
          // Allow Tab to function normally if no item is highlighted
          break;
        case 'Escape':
          event.preventDefault();
          hideDropdownSuggestions(inputElement);
          break;
      }
    }

    function highlightDropdownItem(visibleItems, index) {
      const suggestionBox = visibleItems[0]?.closest('.suggestions');
      if (suggestionBox) { // Remove from all items in this specific dropdown
        suggestionBox.querySelectorAll("li").forEach(item => item.classList.remove("highlight"));
      }
      if (index >= 0 && index < visibleItems.length) {
        visibleItems[index].classList.add("highlight");
        visibleItems[index].scrollIntoView({ block: 'nearest', inline: 'nearest' });
      }
    }

    function selectDropdownItem(inputElement, selectedLi) {
      inputElement.value = selectedLi.textContent.trim();
      inputElement.title = inputElement.value; // Update title attribute
      adjustInputWidth(inputElement); // Adjust width based on new value
      // The blur handler (handleInlineFieldBlur) will save the state.
      // It's triggered by the click handler or after Enter/Tab.
    }

    function hideDropdownSuggestions(inputElement) {
      const suggestionBox = inputElement.closest('.custom-dropdown')?.querySelector(".suggestions");
      if (suggestionBox) {
        suggestionBox.style.display = "none";
        highlightDropdownItem(Array.from(suggestionBox.querySelectorAll("li")), -1); // Clear highlight

        // Remove from active dropdowns when hidden
        const index = activeDropdowns.indexOf(suggestionBox);
        if (index !== -1) {
          activeDropdowns.splice(index, 1);

          // Remove scroll listener if no active dropdowns remain
          if (activeDropdowns.length === 0) {
            window.removeEventListener('scroll', handleScrollForDropdowns);
          }
        }
      }
    }

    function processDropdownBlur(inputElement) {
      // Delay hiding to allow click on suggestion to register
      setTimeout(() => {
        // Check if focus has moved to an element *within the same custom dropdown's suggestions*
        const dropdownContainer = inputElement.closest('.custom-dropdown');
        const suggestionBox = dropdownContainer?.querySelector('.suggestions');
        const activeElement = document.activeElement;

        // If the new active element is a child of this suggestion box, don't hide.
        // The click on the suggestion will handle selection and hiding.
        if (suggestionBox && suggestionBox.contains(activeElement)) {
          return;
        }
        hideDropdownSuggestions(inputElement);
        // The main blur handler (handleInlineFieldBlur) attached to the input will save its value.
      }, 150);
    }

    function handleScrollForDropdowns() {
      // If no active dropdowns, remove the scroll listener
      if (activeDropdowns.length === 0) {
        window.removeEventListener('scroll', handleScrollForDropdowns);
        return;
      }

      // Process each active dropdown
      activeDropdowns.forEach((suggestionBox, index) => {
        // Skip if dropdown is no longer in DOM or is hidden
        if (!document.body.contains(suggestionBox) || suggestionBox.style.display === 'none') {
          activeDropdowns.splice(index, 1);
          return;
        }

        // Get the linked input element
        const inputId = suggestionBox.dataset.linkedInputId;
        if (!inputId) return;

        const inputElement = document.getElementById(inputId);
        if (!inputElement) return;

        // Get the li ancestor for context
        const liAncestor = inputElement.closest('li[data-id]');
        if (!liAncestor) return;

        // Reposition the dropdown based on new scroll position
        positionDropdownSuggestions(inputElement, suggestionBox, liAncestor);
      });
    }


    // --- Final Text Generation ---
    document.getElementById("generateBtn").addEventListener("click", async () => {
      const finalTextArea = document.getElementById("finalText");
      const changesDetected = storeAllInlineValues(); // Capture all current input values

      // Fix: Re-implement overwrite confirmation when the final text area has content
      if (finalTextArea.value.trim() !== "") {
        showConfirmationModal(
          "Generate Text",
          "This will overwrite the current text in the final narrative area. Continue?",
          "",
          () => generateAndDisplayText(finalTextArea), // Yes callback
          () => { } // No callback (do nothing)
        );
      } else {
        // If textarea is empty, generate immediately without confirmation
        generateAndDisplayText(finalTextArea);
      }
    });

    /**
     * Generates the final text with information about locked sentences
     * @returns {Array} [finalText, hasLockedSentences, lockedSectionsInfo, lockedSentencesCount]
     */
    function generateFinalTextWithLockInfo() {
      let finalTextParts = [];
      let hasLockedSentences = false;
      let lockedSentencesCount = 0;
      let lockedSectionsInfo = [];

      // Fix: Get the state of the "Include Section Titles" checkbox
      const includeSectionTitles = document.getElementById("toggleSectionTitles")?.checked || false;

      narrativeSections.forEach(section => {
        if (!section.sentences || section.sentences.length === 0) return;

        let sectionHasLockedSentence = false;
        let sectionText = '';

        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.locked) {
            sectionHasLockedSentence = true;
            hasLockedSentences = true;
            lockedSentencesCount++;
          }

          let processedText;
          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            // For tabbed sentences, use the active tab's text
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const tabText = sentenceObj.tabs[activeTabIndex].text || "";
              const tabValues = sentenceObj.tabValues?.[activeTabIndex] || {};
              processedText = processSentence(tabText, tabValues);
            } else {
              processedText = "";
            }
          } else {
            // For non-tabbed sentences
            processedText = processSentence(sentenceObj.text || "", sentenceObj.values || {});
          }

          if (processedText.trim()) {
            sectionText += processedText.trim() + " ";
          }
        });

        if (sectionText.trim()) {
          // Include section titles when checkbox is checked
          if (includeSectionTitles) {
            finalTextParts.push(`${section.part}:\n${sectionText.trim()}`);
          } else {
            finalTextParts.push(sectionText.trim());
          }

          if (sectionHasLockedSentence) {
            lockedSectionsInfo.push(section.part);
          }
        }
      });

      return [finalTextParts.join("\n\n"), hasLockedSentences, lockedSectionsInfo, lockedSentencesCount];
    }

    /**
     * Generates and displays the final text
     * @param {HTMLElement} finalTextArea - The text area to display the text in
     */
    function generateAndDisplayText(finalTextArea) {
      try {
        const [finalText, hasLockedSentences, lockedSectionsInfo, lockedSentencesCount] = generateFinalTextWithLockInfo();
        finalTextArea.value = finalText;

        // Track Receiving Facility values in the background
        trackReceivingFacilities();

        // If there are locked sentences, show an indicator
        const copyLockedInfoEl = document.getElementById('copyLockedInfo') || createCopyLockedInfoElement();
        if (hasLockedSentences) {
          const sentenceText = lockedSentencesCount === 1 ? 'sentence' : 'sentences';
          copyLockedInfoEl.innerHTML = `<i class="bi bi-lock-fill text-primary"></i> ${lockedSentencesCount} locked ${sentenceText}`;
          copyLockedInfoEl.style.display = 'block';
          copyLockedInfoEl.title = `Sections with locked content: ${lockedSectionsInfo.join(', ')}`;
        } else {
          copyLockedInfoEl.style.display = 'none';
        }

        // Only check for empty placeholders when generating text
        const hasEmptyFields = checkForEmptyPlaceholders();
        showPlaceholderWarning(hasEmptyFields);
      } catch (error) {
        console.error("Error generating final text:", error);
        showConfirmationModal("Error", "Failed to generate text. Please check console for details.", "", () => { }, () => { }, true);
      }
    }

    /**
     * Tracks and sends Receiving Facility values to the API
     */
    function trackReceivingFacilities() {
      const receivingFacilities = new Set(); // Use Set to automatically handle duplicates
      
      // Search through all narrative sections for Receiving Facility values
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        
        section.sentences.forEach(sentenceObj => {
          // Handle tabbed sentences
          if (sentenceObj.tabs && Array.isArray(sentenceObj.tabs)) {
            sentenceObj.tabValues.forEach((tabValues, tabIndex) => {
              if (tabValues && tabValues['Receiving Facility']) {
                const facilityValue = tabValues['Receiving Facility'].trim();
                if (facilityValue && facilityValue !== '[Receiving Facility]') {
                  receivingFacilities.add(facilityValue);
                }
              }
            });
          } 
          // Handle non-tabbed sentences
          else if (sentenceObj.values && sentenceObj.values['Receiving Facility']) {
            const facilityValue = sentenceObj.values['Receiving Facility'].trim();
            if (facilityValue && facilityValue !== '[Receiving Facility]') {
              receivingFacilities.add(facilityValue);
            }
          }
        });
      });
      
      // Send each unique facility value to the API
      receivingFacilities.forEach(facility => {
        sendFacilityToAPI(facility);
      });
      
      if (receivingFacilities.size > 0) {
        console.log(`Tracked ${receivingFacilities.size} unique receiving facilities:`, Array.from(receivingFacilities));
      }
    }

    /**
     * Sends a receiving facility value to the API
     * @param {string} facilityName - The name of the receiving facility
     */
    async function sendFacilityToAPI(facilityName) {
      try {
        const payload = {
          type: 'receiving_facility',
          facility_name: facilityName,
          timestamp: new Date().toISOString(),
          user_agent: navigator.userAgent,
          config_name: currentConfigName
        };
        
        const response = await fetch('https://api.bbrown.access.ly/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log(`Successfully tracked facility: ${facilityName}`, result);
        } else {
          console.warn(`Failed to track facility: ${facilityName}. Status: ${response.status}`);
        }
      } catch (error) {
        // Fail silently for tracking - don't interrupt user experience
        console.warn(`Error tracking facility "${facilityName}":`, error);
      }
    }

    /**
     * Creates an info element for displaying locked sentence information
     */
    function createCopyLockedInfoElement() {
      const infoEl = document.createElement('div');
      infoEl.id = 'copyLockedInfo';
      infoEl.classList.add('copy-locked-info', 'text-muted', 'small', 'mt-2');

      // Insert after final text area
      const finalTextArea = document.getElementById('finalText');
      finalTextArea.parentNode.insertBefore(infoEl, finalTextArea.nextSibling);

      return infoEl;
    }

    /**
     * Process a sentence by replacing placeholders with values
     * Fix: Show [placeholder] when values are empty or missing
     */
    function processSentence(text, values) {
      if (!text) return "";
      if (!values) values = {};

      return text.replace(placeholderRegex, (match, type, label) => {
        const value = values[label];
        // Fix: Return [label] if value is empty, null, undefined, or just whitespace
        return (value && value.toString().trim()) ? value.toString().trim() : `[${label}]`;
      });
    }

    // --- Button Event Listeners ---
    document.getElementById("copyBtn").addEventListener("click", () => {
      const finalTextArea = document.getElementById("finalText");
      const textToCopy = finalTextArea.value.trim();
      if (!textToCopy) {
        showConfirmationModal("Copy", "Nothing to copy!", "", () => { }, () => { }, true);
        return;
      }
      navigator.clipboard.writeText(textToCopy).then(() => {
        console.log("Text copied to clipboard.");
        showConfirmationModal("Copied to Clipboard",
          "The final narrative has been copied to the clipboard.<br><br>Would you like to start a new run?",
          // Fix: Use HTML for disclaimer to properly render the <br> tag
          "<span>Paste your narrative first,</span><br><span>unlocked sentences will be reset to their default values.</span>",
          () => {
            console.log("Final narrative area cleared after copy and confirmation.");
            // Clear the final text area
            finalTextArea.value = '';
            // Reset all sentences to current config defaults
            resetToCurrentConfigDefaults();
            // Clear the placeholder warning
            showPlaceholderWarning(false);
            // Clear the locked sentences info
            const copyLockedInfoEl = document.getElementById('copyLockedInfo');
            if (copyLockedInfoEl) {
              copyLockedInfoEl.style.display = 'none';
            }
          },
          () => { },
          false, // Not single button
          true // Show lock toggle
        );
      }).catch(err => {
        console.error("Copy to clipboard failed: ", err);
        showConfirmationModal("Copy Failed", "Could not copy text to clipboard. Your browser might not support this feature or has restrictions.", "", () => { }, () => { }, true);
      });
    });

    /**
     * Checks for empty placeholder values in all sentences by examining actual placeholders in text
     * @returns {boolean} True if any empty placeholder values are found
     */
    function checkForEmptyPlaceholders() {
      let hasEmptyFields = false;

      narrativeSections.forEach(section => {
        if (!section.sentences) return;

        section.sentences.forEach(sentenceObj => {
          // Check for empty values in regular sentences
          if (!sentenceObj.tabs) {
            const text = sentenceObj.text || "";
            const values = sentenceObj.values || {};
            
            // Find all placeholders in the text
            const placeholderMatches = [...text.matchAll(placeholderRegex)];
            placeholderMatches.forEach(match => {
              const label = match[2]; // The label is the second capture group
              const value = values[label];
              if (!value || value.trim() === '') {
                hasEmptyFields = true;
              }
            });
          } else {
            // For tabbed sentences, only check the ACTIVE tab
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const activeTab = sentenceObj.tabs[activeTabIndex];
              const text = activeTab.text || "";
              const tabValues = sentenceObj.tabValues[activeTabIndex] || {};
              
              // Find all placeholders in the active tab's text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = tabValues[label];
                if (!value || value.trim() === '') {
                  hasEmptyFields = true;
                }
              });
            }
          }
        });
      });

      return hasEmptyFields;
    }

    /**
     * Highlights empty placeholder fields in the UI
     * @param {boolean} highlight Whether to add or remove highlighting
     */
    function highlightEmptyFields(highlight = true) {
      // Remove existing highlights first
      document.querySelectorAll('.inline-field.empty-field').forEach(field => {
        field.classList.remove('empty-field');
      });

      if (!highlight) return;

      narrativeSections.forEach(section => {
        if (!section.sentences) return;

        section.sentences.forEach(sentenceObj => {
          const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
          if (!li) return;

          // Check for empty values in regular sentences
          if (!sentenceObj.tabs) {
            const text = sentenceObj.text || "";
            const values = sentenceObj.values || {};
            
            // Find all placeholders in the text
            const placeholderMatches = [...text.matchAll(placeholderRegex)];
            placeholderMatches.forEach(match => {
              const label = match[2]; // The label is the second capture group
              const value = values[label];
              if (!value || value.trim() === '') {
                // Find and highlight the corresponding input field
                const field = li.querySelector(`.inline-field[data-label="${label}"]:not(.tab-pane .inline-field)`);
                if (field) {
                  field.classList.add('empty-field');
                }
              }
            });
          } else {
            // For tabbed sentences, only check the ACTIVE tab
            const activeTabIndex = sentenceObj.activeTabIndex || 0;
            if (activeTabIndex < sentenceObj.tabs.length) {
              const activeTab = sentenceObj.tabs[activeTabIndex];
              const text = activeTab.text || "";
              const tabValues = sentenceObj.tabValues[activeTabIndex] || {};
              
              // Find all placeholders in the active tab's text
              const placeholderMatches = [...text.matchAll(placeholderRegex)];
              placeholderMatches.forEach(match => {
                const label = match[2]; // The label is the second capture group
                const value = tabValues[label];
                if (!value || value.trim() === '') {
                  // Find and highlight the corresponding input field in the active tab
                  const tabPane = li.querySelector(`.tab-pane[data-tab-index="${activeTabIndex}"]`);
                  if (tabPane) {
                    const field = tabPane.querySelector(`.inline-field[data-label="${label}"]`);
                    if (field) {
                      field.classList.add('empty-field');
                    }
                  }
                }
              });
            }
          }
        });
      });
    }

    /**
     * Shows or hides the placeholder warning and highlights empty fields
     * @param {boolean} show Whether to show the warning
     */
    function showPlaceholderWarning(show) {
      const finalTextArea = document.getElementById("finalText");
      const warningContainer = document.getElementById("placeholderWarningContainer") || createWarningElement();

      if (show) {
        finalTextArea.classList.add("has-empty-placeholders");
        warningContainer.style.display = "block";
        highlightEmptyFields(true);
      } else {
        finalTextArea.classList.remove("has-empty-placeholders");
        warningContainer.style.display = "none";
        highlightEmptyFields(false);
      }
    }

    /**
     * Creates the warning element if it doesn't exist
     * @returns {HTMLElement} The warning container element
     */
    function createWarningElement() {
      const finalTextArea = document.getElementById("finalText");
      const finalTextContainer = finalTextArea.parentElement;

      const warningContainer = document.createElement("div");
      warningContainer.id = "placeholderWarningContainer";
      warningContainer.classList.add("placeholder-warning", "text-danger");
      warningContainer.innerHTML = '<i class="bi bi-exclamation-triangle-fill"></i> Warning: Some placeholder values remain!';

      // Insert before the textarea
      finalTextContainer.insertBefore(warningContainer, finalTextArea);
      return warningContainer;
    }

    /**
     * Simple debounce function to limit how often a function is called
     */
    function debounce(func, wait) {
      let timeout;
      return function () {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // --- UI Building for Final Text Generation ---
    function renderSectionText(section) {
      let sectionText = "";
      let sectionHasContent = false;
      const includeSectionTitles = document.getElementById("toggleSectionTitles").checked;

      section.sentences.forEach(sentenceObj => {
        let currentSentenceText = "";
        // Determine if it's a tabbed sentence or regular
        if (sentenceObj.tabs?.length) {
          const activeTab = sentenceObj.tabs[sentenceObj.activeTabIndex];
          if (!activeTab) return; // Skip if no active tab somehow
          const tabValues = sentenceObj.tabValues[sentenceObj.activeTabIndex] || {};
          currentSentenceText = (activeTab.text || "").replace(placeholderRegex, (match, type, label) => {
            return (tabValues[label] || "").trim() || `[${label}]`; // Use placeholder if value is empty
          });
        } else { // Regular sentence
          const values = sentenceObj.values || {};
          currentSentenceText = (sentenceObj.text || "").replace(placeholderRegex, (match, type, label) => {
            return (values[label] || "").trim() || `[${label}]`; // Use placeholder if value is empty
          });
        }
        // Clean up and add to section text
        currentSentenceText = currentSentenceText.replace(/<br\s*\/?>/gi, "").replace(/\s+/g, ' ').trim();
        if (currentSentenceText) {
          sectionText += currentSentenceText + " ";
          sectionHasContent = true;
        }
      });

      if (sectionHasContent) {
        if (section.includeTitle && includeSectionTitles) {
          sectionText = section.part + ":\n" + sectionText.trim();
        }
        return sectionText.trim() + "\n\n";
      }
      return "";
    }

    // --- Utility Functions ---
    function findSentenceById(id) {
      for (const sec of narrativeSections) {
        if (!sec.sentences) continue;
        const sentence = sec.sentences.find(s => s.id === id);
        if (sentence) return sentence;
      }
      console.warn(`Sentence with ID ${id} not found in any section.`);
      return null;
    }

    // --- Input Auto-Sizing ---
    function attachInputSizingListeners() {
      const container = document.getElementById('sectionContainer');
      if (container) {
        // Use event delegation for efficiency
        container.removeEventListener('input', handleAutoSizingInputDelegated);
        container.addEventListener('input', handleAutoSizingInputDelegated);
      }
    }
    function attachInputSizingListenersForElement(element) {
      element.querySelectorAll('.inline-field, .auto-height-textarea').forEach(input => {
        input.removeEventListener('input', handleAutoSizingInputDirect); // Prevent duplicates
        input.addEventListener('input', handleAutoSizingInputDirect);
      });
    }

    function handleAutoSizingInputDelegated(event) {
      if (event.target.matches('.inline-field')) adjustInputWidth(event.target);
      else if (event.target.matches('.auto-height-textarea')) adjustTextareaHeight(event.target);
    }
    function handleAutoSizingInputDirect(event) { // For dynamically added elements
      if (event.target.matches('.inline-field')) adjustInputWidth(event.target);
      else if (event.target.matches('.auto-height-textarea')) adjustTextareaHeight(event.target);
    }

    function adjustTextareaHeight(textarea) {
      if (!textarea) return;
      textarea.style.height = 'auto'; // Temporarily shrink to get scrollHeight
      const newHeight = Math.max(textarea.scrollHeight, parseFloat(getComputedStyle(textarea).minHeight) || 0);
      textarea.style.height = `${newHeight}px`;
    }

    function adjustInputWidth(input) {
      if (!input || !widthMeasurerSpan) return;
      const inputStyle = window.getComputedStyle(input);
      const isCustomDropdown = input.classList.contains('custom-dropdown-input');
      // Use a slightly larger base min-width for custom dropdowns to accommodate potential dropdown arrows or icons if added later
      const minWidth = parseFloat(inputStyle.minWidth) || (isCustomDropdown ? 80 : MIN_INLINE_WIDTH);

      widthMeasurerSpan.style.font = inputStyle.font;
      widthMeasurerSpan.textContent = input.placeholder || ' '; // Measure placeholder width
      const placeholderWidth = widthMeasurerSpan.scrollWidth;
      widthMeasurerSpan.textContent = input.value || ' '; // Measure value width
      const valueWidth = widthMeasurerSpan.scrollWidth;

      // Add a small buffer (e.g., 2-5px) to prevent text from touching the edge
      const contentWidthBuffer = 5;
      const requiredContentWidth = Math.max(valueWidth, placeholderWidth) + contentWidthBuffer;

      const parentLi = input.closest('li[data-id]'); // Get parent list item
      let parentWidth = parentLi?.clientWidth || window.innerWidth; // Fallback to window width
      // Reduce available parent width slightly to account for padding/margins on the LI or controls
      parentWidth = parentWidth * 0.9;

      let maxWidth = parentWidth * (MAX_INLINE_WIDTH_PERCENT / 100);
      maxWidth = Math.max(maxWidth, minWidth * 1.5); // Ensure max width is at least 1.5x min width

      const newWidth = Math.min(maxWidth, Math.max(minWidth, requiredContentWidth));
      input.style.width = `${newWidth}px`;
    }

    function adjustAllInitialSizes() {
      document.querySelectorAll('.inline-field').forEach(input => adjustInputWidth(input));
      document.querySelectorAll('.auto-height-textarea').forEach(textarea => adjustTextareaHeight(textarea));
    }
    function adjustAllInitialSizesForElement(element) {
      element.querySelectorAll('.inline-field').forEach(input => adjustInputWidth(input));
      element.querySelectorAll('.auto-height-textarea').forEach(textarea => adjustTextareaHeight(textarea));
    }


    // --- Modal Dialog ---
    function showConfirmationModal(title, message, disclaimer, callbackYes, callbackNo, singleButton = false, showLockToggle = false) {
      const modalEl = document.getElementById("confirmationModal");
      if (!modalEl) { console.error("Confirmation modal element not found!"); return; }

      const modalLabel = modalEl.querySelector("#confirmationModalLabel");
      const modalBody = modalEl.querySelector("#confirmationModalBody");
      const modalDisclaimer = modalEl.querySelector("#confirmationDisclaimer");
      const yesBtn = modalEl.querySelector("#confirmYesBtn");
      const noBtn = modalEl.querySelector("#confirmNoBtn");
      const lockToggleBtn = modalEl.querySelector("#confirmationLockToggle");

      if (!modalLabel || !modalBody || !modalDisclaimer || !yesBtn || !noBtn || !lockToggleBtn) {
        console.error("One or more modal sub-elements not found!");
        return;
      }
      const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);

      modalLabel.textContent = title || "Confirmation";
      modalBody.innerHTML = message || ""; // Use innerHTML to allow for <br> etc.

      // Fix: Use innerHTML for disclaimer to properly render HTML content if needed
      modalDisclaimer.innerHTML = disclaimer || "";

      yesBtn.style.display = singleButton ? 'none' : 'inline-block';
      noBtn.textContent = singleButton ? 'OK' : 'No';

      // Show/hide lock toggle button based on parameter
      lockToggleBtn.style.display = showLockToggle ? 'inline-block' : 'none';
      
      // Initialize lock toggle state (locked by default)
      let unlockLockedSentences = false;
      if (showLockToggle) {
        lockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
        lockToggleBtn.title = 'Click to also reset locked sentences';
        lockToggleBtn.classList.remove('btn-warning');
        lockToggleBtn.classList.add('btn-outline-secondary');
      }

      // Remove previous listeners before adding new ones to prevent multiple calls
      const newYesBtn = yesBtn.cloneNode(true);
      yesBtn.parentNode.replaceChild(newYesBtn, yesBtn);
      const newNoBtn = noBtn.cloneNode(true);
      noBtn.parentNode.replaceChild(newNoBtn, noBtn);
      const newLockToggleBtn = lockToggleBtn.cloneNode(true);
      lockToggleBtn.parentNode.replaceChild(newLockToggleBtn, lockToggleBtn);

      newYesBtn.style.display = singleButton ? 'none' : 'inline-block';
      newNoBtn.textContent = singleButton ? 'OK' : 'No';
      newLockToggleBtn.style.display = showLockToggle ? 'inline-block' : 'none';

      // Lock toggle functionality
      if (showLockToggle) {
        newLockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
        newLockToggleBtn.title = 'Click to also reset locked sentences';
        newLockToggleBtn.classList.remove('btn-warning');
        newLockToggleBtn.classList.add('btn-outline-secondary');

        newLockToggleBtn.addEventListener('click', () => {
          unlockLockedSentences = !unlockLockedSentences;
          if (unlockLockedSentences) {
            newLockToggleBtn.innerHTML = '<i class="bi bi-unlock-fill"></i>';
            newLockToggleBtn.title = 'Will reset locked sentences';
            newLockToggleBtn.classList.remove('btn-outline-secondary');
            newLockToggleBtn.classList.add('btn-danger');
          } else {
            newLockToggleBtn.innerHTML = '<i class="bi bi-lock-fill"></i>';
            newLockToggleBtn.title = 'Click to also reset locked sentences';
            newLockToggleBtn.classList.remove('btn-danger');
            newLockToggleBtn.classList.add('btn-outline-secondary');
          }
        });
      }

      newYesBtn.addEventListener('click', () => {
        bsModal.hide();
        if (callbackYes && typeof callbackYes === 'function') {
          // If unlock toggle was enabled and activated, unlock all sentences first
          if (showLockToggle && unlockLockedSentences) {
            unlockAllSentences();
          }
          callbackYes();
        }
      });
      newNoBtn.addEventListener('click', () => {
        bsModal.hide();
        if (callbackNo && typeof callbackNo === 'function') callbackNo();
      });
      bsModal.show();
    }

    // Function to unlock all locked sentences
    function unlockAllSentences() {
      let unlockedCount = 0;
      narrativeSections.forEach(section => {
        if (!section.sentences) return;
        section.sentences.forEach(sentenceObj => {
          if (sentenceObj.locked) {
            sentenceObj.locked = false;
            unlockedCount++;
          }
        });
      });
      console.log(`Unlocked ${unlockedCount} sentences`);
      saveState(); // Save the unlocked state
    }

    // Bug Report initialization function
    function initializeBugReport() {
      console.log("Initializing bug report functionality...");
      const bugReportBtn = document.getElementById('bugReportBtn');
      const bugReportModalEl = document.getElementById('bugReportModal');

      if (!bugReportBtn || !bugReportModalEl) {
        console.error("Bug report button or modal not found!");
        return;
      }

      // Update the icon to use the solid version
      if (bugReportBtn.querySelector('i')) {
        bugReportBtn.querySelector('i').className = 'bi bi-bug-fill';
      }

      const bugReportModal = new bootstrap.Modal(bugReportModalEl);

      // Add click event to show the modal
      bugReportBtn.addEventListener('click', () => {
        bugReportModal.show();
      });

      // Setup submit button functionality
      const submitBugBtn = document.getElementById('submitBug');
      if (submitBugBtn) {
        submitBugBtn.addEventListener('click', () => {
          const desc = document.getElementById('bugDescription').value;
          if (desc.trim()) {
            // Encode the bug description for URL
            const encodedDescription = encodeURIComponent(desc.trim());

            // Construct the Google Forms URL with the bug report
            const formUrl = `https://docs.google.com/forms/d/e/1FAIpQLSfiovEazZnz0HhEULNqjiyrbC6CyhPi0MVd7qWeJvKUTWoBIA/formResponse?submit=Submit&usp=pp_url&entry.1588653800=${encodedDescription}`;

            // Open the form in a new tab
            window.open(formUrl, '_blank');

            // Clear the textarea and hide the modal
            document.getElementById('bugDescription').value = '';
            bugReportModal.hide();

            // Show confirmation message
            showConfirmationModal(
              "Bug Report Submitted",
              "Thank you for your bug report!",
              "",
              () => { },
              () => { },
              true
            );
          } else {
            // Show error if description is empty
            showConfirmationModal(
              "Bug Report",
              "Please enter a description of the bug before submitting.",
              "",
              () => { },
              () => { },
              true
            );
          }
        });
      }

      console.log("Bug report functionality initialized.");
    }
  </script>
</body>

</html>